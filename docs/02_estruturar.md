1. tidyr
--------

O `tidyr` √© o pacote utilizado para estruturar os nossos bancos de
dados. Em geral, ele pode ser utilizado para **unir** (`unite`) e
**separar** (`separate`) colunas ou para **derreter** (`gather`) e
**esticar** (`spread`) as colunas.

Esse pacote √© contru√≠do com base no conceito de `tidy data`. Deixar o
seus dados `tidy` significa transformar a **estrutura** dos dados de tal
maneira que tenhamos observa√ß√µes nas linhas, vari√°veis nas colunas e
valores nas c√©lulas. Em geral, esperamos tamb√©m que um banco `tidy`
contenha apenas uma unidade de observa√ß√£o, granularidade, etc.

![](imgs/r_tidy_data.png)
<center>
Ilustra√ß√£o do Tidy Data (Fonte:
<a href="http://statseducation.com" class="uri">http://statseducation.com</a>)
</center>
!!! question " O que √© unidade de observa√ß√£o / granularidade? "

    Trata-se da unidade contida nas linhas do seu banco. Por exemplo, se montarmos um banco de dados com 
    informa√ß√µes sobre __pessoas__ (altura, idade, peso, etc.) em cada linha teremos __pessoas__ como unidade de 
    observa√ß√£o.

    Tente imaginar a unidade de observa√ß√£o de informa√ß√µes como PIP, desemprego, entre outras coisas.s

### 1.1 separate

-   [Download do
    Banco](https://github.com/p4hUSP/material-bio/raw/master/docs/data/ramen-ratings.zip)

Vamos come√ßar abrindo o nosso banco. Repare que j√° estamos carregando o
pacote `tidyr`.

!!! warning " Instalando pacotes "

    Caso voc√™ n√£o tenha o `tidyr` no seu computador, por favor, execute o c√≥digo `install.packages('tidyr')`.

    library(readr)
    library(tidyr)

    banco <- read_csv('data/ramen-ratings.zip')

`separate()` √© uma fun√ß√£o do pacote `tidyr` que tem como objetivo
**separar** valores contidos em uma coluna. √Äs vezes, mais de uma
informa√ß√£o √© agrupado dentro da mesma coluna. Voc√™ consegue identificar
no nosso banco de dados em qual coluna isso acontece?

!!! question " Fun√ß√µes para explorar dataframes "

    Tente utilizar fun√ß√µes para explorar o seu dataframe. Por exemplo, com `head()` conseguimos obter facilmente
    as primeiras linhas do nosso banco. Experiemente utilizar `table()` dessa vez j√° que o banco possu√≠ uma quantidade 
    razo√°vel de vari√°veis categ√≥ricas.

Voc√™ percebeu alguma coisa de estranho na vari√°vel `Top Ten`? O que? Se
voc√™ percebeu que na verdade ela cont√©m duas vari√°veis, parab√©ns! :tada:
Agora temos um exemplo para usarmos a fun√ß√£o `separate()`.

Como o `separate()` funciona? Tente executar o comando `?separate`. A
documenta√ß√£o do `tidyverse` tende a ser muito boa e normalmente teremos
uma boa explica√ß√£o de como a fun√ß√£o opera e de quais par√¢metros
precisamos utilizar nela.

No caso, o `separate()` recebe (1) no primeiro par√¢metro o banco de
dados, (2) no segundo, a coluna que desejamos separar, (3) na terceira o
nome das colunas que desejamos criar a partir da coluna informada no
segundo par√¢metro, (4) o separador, ou seja, o padr√£o de caracteres que
ser√£o utilizados para separar a coluna do segundo par√¢metro nas colunas
espec√≠ficadas no terceiro par√¢metro. Isso pode parecer complicado, mas √©
bem simples.

    separate(<dataframe>, <coluna_que_desejamos_separar>, <vetor_com_as_colunas_a_serem_criadas>, <separador>)

Vamos l√°? üí™

    separate(banco, 'Top Ten', c('top_year', 'top_position'), '#', remove = FALSE)

Que tal dar um `View()` no seu banco agora?

    View(banco)

!!! warning " Salvando altera√ß√µes "

    Nunca se esque√ßa de que o R n√£o sabe que voc√™ deseja sobrescrever uma vari√°vel. Ao contr√°rio do Stata, por exemplo, as altera√ß√µes devem ser escritas sobre uma vari√°vel com `<-`. Caso contr√°rio, o R ir√° apenas imprimir no console o resultado.

<br/>

    banco <- separate(banco, 'Top Ten', c('top_year', 'top_position'), '#', remove = FALSE)

Agora, podemos utilizar o `View()` ou o `head()` para verificar se deu
tudo certo.

### unite

A fun√ß√£o `unite()` faz o oposto da `separate()`. O nome dela j√° entrega
o objetivo dela, que √© **unir** ou **concatenar** colunas. Um dos
melhores exemplos de uso dessa fun√ß√£o √© unir as vari√°veis de `dia`,
`m√™s` e `ano`. Como n√£o temos essa informa√ß√£o no nosso banco, vamos
adicionar algumas datas de mentira.

    set.seed(12345)

    banco$fake_dia <- replicate(nrow(banco), sample(1:28, 1))
    banco$fake_mes <- replicate(nrow(banco), sample(1:12, 1))
    banco$fake_ano <- replicate(nrow(banco), sample(2002:2016, 1))

Ap√≥s executar o c√≥digo acima, vamos prossguir com a fun√ß√£o `unite()`.
Ela recebe (1) no primeiro par√¢metro o banco de dados e (2) no segundo o
nome da **nova** vari√°vel. Em seguida, (3) podemos adicionar os nodemos
de todas as colunas que queremos concatenar (4) e, por fim, podemos
escolher o separador entre as colunas.

    banco <- unite(banco, "data", fake_ano, fake_mes, fake_dia, sep = "-")

Virique o resultado com a fun√ß√£o `head()`.

Exerc√≠cios - Parte 1
--------------------

### Exerc√≠cio - Exemplos de `unite` e `separate`

Para cada tabela abaixo diga se √© necess√°rio realizar um `unite()` ou um
`separate()`. Em seguinda, escreva o c√≥digo que voc√™ utilizaria.

<br/>

<center>
<table>
<thead>
<tr class="header">
<th>CIDADE</th>
<th>PIB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>‚ÄúS√£o Jos√© dos Campos - SP‚Äù</td>
<td>19.2</td>
</tr>
<tr class="even">
<td>‚ÄúS√£o Paulo - SP‚Äù</td>
<td>20</td>
</tr>
<tr class="odd">
<td>‚ÄúPorto Alegre - RS‚Äù</td>
<td>8.2</td>
</tr>
</tbody>
</table>

</center>
<br/>

<center>
<table>
<thead>
<tr class="header">
<th>CIDADE</th>
<th>ALUNOS - ESCOLAS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S√£o Jos√© dos Campos</td>
<td>19292 - 1882</td>
</tr>
<tr class="even">
<td>S√£o Paulo</td>
<td>21828 - 102</td>
</tr>
<tr class="odd">
<td>Porto Alegre</td>
<td>102761 - 98</td>
</tr>
</tbody>
</table>

</center>
<br/>

Nesse √∫ltimo exemplo, imagine que estamos preparando um banco para
realizar uma pesquisa de endere√ßos no Google.

<center>
<table>
<thead>
<tr class="header">
<th>CIDADE</th>
<th>RUA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ubatuba</td>
<td>Rua das Pedras</td>
</tr>
<tr class="even">
<td>Uberl√¢ndia</td>
<td>Avenida Minas Geras</td>
</tr>
<tr class="odd">
<td>Curitiba</td>
<td>Rua dos Cocais</td>
</tr>
</tbody>
</table>

</center>
Exerc√≠cio - unite() e separate() na pr√°tica
-------------------------------------------

1.  Aplique a fun√ß√£o `unite()` nas colunas `Style` e `Country`.

2.  Aplique a fun√ß√£o `separate()` na coluna criada no exerc√≠cio anterior

3. Gather e Spread
------------------

Voc√™ j√° ouviu falar em bancos no formato `wide` e `long`? No geral,
existem duas maneiras de organizar s√©ries temporais. Quando optamos pelo
`wide`, o nosso banco √© ‚Äúesticado‚Äù horizontalmente; enquanto, quanto a
op√ß√£o √© pelo `long`, o banco √© ‚Äúesticado‚Äù verticalmente.

<center>
**PIB na China e no Brasil - Wide**

</center>
<center>
<table>
<thead>
<tr class="header">
<th>Pa√≠s</th>
<th>2015</th>
<th>2016</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brasil</td>
<td>10.2</td>
<td>11.2</td>
</tr>
<tr class="even">
<td>China</td>
<td>14.3</td>
<td>18.4</td>
</tr>
</tbody>
</table>

</center>
<center>
**PIB na China e no Brasil - Long**

</center>
<center>
<table>
<thead>
<tr class="header">
<th>Pa√≠s</th>
<th>Ano</th>
<th>PIB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brasil</td>
<td>2015</td>
<td>10.2</td>
</tr>
<tr class="even">
<td>Brasil</td>
<td>2016</td>
<td>11.2</td>
</tr>
<tr class="odd">
<td>China</td>
<td>2015</td>
<td>14.3</td>
</tr>
<tr class="even">
<td>China</td>
<td>2016</td>
<td>18.4</td>
</tr>
</tbody>
</table>

</center>
### 3.1. `gather()`

`gather()` √© utilizado para derreter/agrupar as colunas dos nossos
bancos. Essa fun√ß√£o recebe (1) o banco de dados, (2) o nome da vari√°vel
que est√° como nome das colunas, (3) o nome da vari√°vel que est√° nas
c√©lulas, (4) os nomes das colunas em que iremos realizar a opera√ß√£o
**sem aspas**.

Ela pode parecer um pouco complicada de se utilizar do que o `unite()` e
o `separate()`, mas com um pouco de pr√°tica ela se torna bastante
intuitiva. Para quem est√° acostumado com o Excel, estamos fazendo uma
`tabela din√¢mica` ou `pivot table`.

    tabela_wide <- tibble::tribble(
      ~Pa√≠s , ~`2015`, ~`2016`,
      'Brasil' , 10.2 , 11.2,
      'China' , 14.3 , 18.4,
    )

    gather(tabela_wide, key = 'ano', value = 'pib' ,`2015`, `2016`)

### 3.2. `spread()`

A fun√ß√£o `spread()` realiza a opera√ß√£o inversa. Ela estica os nossos
dados horizontalmente. Mas isso n√£o acaba com o formato `tidy` do nosso
banco? Sim, mas lembre-se que apenas estruturamos os nossos dados de
acordo com os princ√≠pios `tidy` porque a maior parte das fun√ß√µes esperam
esse tipo de estrutura! Isso n√£o significa que essa √© a melhor maneira
de, por exemplo, apresentar os nossos dados.

A fun√ß√£o `spread()` recebe par√¢metros bem parecidos como a `gather()`.
(1) Primeiro, precisamos fornecer o banco de dados; (2) em segundo
lugar, o nome da vari√°vel cujo os valores ser√£o dispostos como colunas;
(3) por fim, a vari√°vel que fornecer√° os valores para as c√©lulas.

    tabela_long <- tibble::tribble(
      ~pais, ~ano, ~pib,
      'Brasil' , 2015 , 10.2,
      'Brasil' , 2016 , 11.2,
      'China' , 2015 , 14.3,
      'China' , 2016 , 18.4,
    )

    spread(tabela_long, ano, pib)

Exerc√≠cios - Parte 2
--------------------

### Exerc√≠cio - `spread()`

Apresente a tabela abaixo de tal maneira que as UFs fiquem nas linhas e
o nivel de escolaridade esteja distribu√≠do pelas colunas.

    tabela_escolaridade <- tibble::tribble(
      ~UF, ~mes, ~nivel_escolaridade,
      'SP', 'Jan', 20.2,
      'SP', 'Fev', 29.2,
      'SP', 'Mar', 12.3,
      'SP', 'Abr', 14.3,
      'RJ', 'Jan', 28.2,
      'RJ', 'Fev', 19.2,
      'RJ', 'Mar', 9.3,
      'RJ', 'Abr', 30.3,
    )

Fa√ßa a mesma coisa agora com a tabela abaixo e deixe o pa√≠s nas linhas.

    tabela_pais <- tibble::tribble(
      ~pais, ~ano, ~venda,
      'Brasil', 2014, 20.2,
      'Brasil', 2015, 29.2,
      'Brasil', 2016, 12.3,
      'Brasil', 2017, 14.3,
      'Colombia', 2014, 28.2,
      'Colombia', 2015, 19.2,
      'Colombia', 2016, 9.3,
      'Colombia', 2017, 30.3,
    )

### Exerc√≠cio - `gather()`

Transforme as pr√≥ximas tabelas em formato `tidy`.

-   Escolaridade:

<!-- -->

    tabela_pais_escol <- tibble::tribble(
      ~pais, ~`Jan`, ~`Fev`,
      'China', 92, 20.2,
      'EUA', 10.2, 42,
      'Fran√ßa', 72.2, 26,
      'Chile', 80.2, 90,
      'Jap√£o', 19.1, 25,
    )

-   Mortes por arma de fogo

<!-- -->

    tabela_arma_fogo <- tibble::tribble(
      ~UF, ~`2015`, ~`2016`,
      'SP', 92, 20.2,
      'RJ', 10.2, 42,
      'RS', 72.2, 26,
      'CO', 80.2, 90,
      'PE', 19.1, 25,
    )

4. `dplyr`
----------

Dentre os pacotes mais importantes do `tidyverse`, o `dplyr` se destaca.
Ele traz uma biblioteca poderasa de fun√ß√µes que nos permitem transformar
dados. Essa √© a tarefa que voc√™ provavelmente passar√° mais tempo fazendo
j√° que nem sempre os dados est√£o limpos. Muitas vezes teremos que criar
vari√°veis ou extrair parte da informa√ß√£o presente em uma para que possas
rodar um modelo.

Quais s√£o os verbos do `dplyr`? Obviamente, o pacote √© extenso e possui
uma quantidade razo√°vel de fun√ß√µes, mas queremos que voc√™ se atente,
agora, a tr√™s fun√ß√µes: `select()`, `filter()`, `mutate()`.

### 4.1. `select()`

O `select()` √© capaz de selecionar colunas espec√≠ficas do nosso banco de
dados.

Vamos carregar novamente o banco de *ramen*.

    library(dplyr)
    library(readr)

    banco <- read_csv('data/ramen-ratings.zip')

Digamos que seja mais relevante apresentar apenas as vari√°veis `Brand` e
`Stars`.

    select(banco, Brand, Stars)

Parece bem simples, n√£o? Repare apenas que n√£o colocamos aspas nos nomes
das vari√°veis dentro do `select()`. Isso √© uma coisa um pouco ruim do
`tidyverse` j√° que √†s vezes precisamos colocar as aspas e √†s vezes n√£o.
Fique atento para n√£o errar isso e caso tenha d√∫vidas d√™ uma olhada na
documenta√ß√£o da fun√ß√£o com `?select`.

### 4.2. `filter()`

Novamente, o nome da fun√ß√£o j√° entrega o objetivo dela. `filter()`
filtra (d√£√£) as **observa√ß√µes** da nossa tabela. Digamos que voc√™ esteja
de viagem para o Jap√£o e que queira olhar apenas as avalia√ß√µes desse
pa√≠s. Para obter esse resultado, voc√™ ter√° que fazer uso dos
`operadores l√≥gicas`

!!! question " Operadores l√≥gicos "

    N√≥s vimos na primeira aula que operadores l√≥gicas s√£o opera√ß√µes que retornam 
    necessariamente apenas dois resultados: verdadeiro e falso. A partir de agora, come√ßaremos a
    utilizar eles cada vez mais. Ent√£o, se n√£o estiver se sentindo confort√°vel com o tema, volte
    para a primeira aula e reveja os exemplos.

Qual o operador l√≥gico que testa igualdade? Se voc√™ pensou no `==`,
acertou! :tada: Agora, s√≥ precisamos coloc√°-lo dentro do `filter()` e
deixar que m√°gica aconte√ßa. Assim como nas outras fun√ß√µes, (1) o
primeiro argumento √© o banco de dados. (2) O segundo, no caso, √© o teste
que queremos realisar . Repare que `filter()` ir√° retornar todos os
valores que tiverem como resposta para o teste o valor `TRUE`. Logo, no
exemplo abaixo, ser√£o retornados todas as observa√ß√µes em que `Country`
seja igual a `Japan`.

    filter(banco, Country == 'Japan')
