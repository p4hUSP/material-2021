---
title: "Estruturar"
author: "P4H"
output: md_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12,
                      fig.height=8,
                      warning=FALSE,
                      message=FALSE,
                      eval=FALSE)
```

Hoje, vamos trabalhar com um banco de dados sobre _doen√ßas card√≠acas_. O dado est√° dispon√≠vel [UCI - Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/Heart+Disease) e no [Kaggle](https://www.kaggle.com/ronitf/heart-disease-uci/downloads/heart-disease-uci.zip/1). Os respons√°veis pelo estudo foram as seguintes entidades:

1. Hungarian Institute of Cardiology. Budapest: Andras Janosi, M.D.
2. University Hospital, Zurich, Switzerland: William Steinbrunn, M.D.
3. University Hospital, Basel, Switzerland: Matthias Pfisterer, M.D.
4. V.A. Medical Center, Long Beach and Cleveland Clinic Foundation: Robert Detrano, M.D., Ph.D. 

A diagn√≥stico de doen√ßa card√≠aca foi feita a partir de uma angiografia. Se houvesse estreitamento maior do que 50% para pelo menos um vaso sangu√≠neo principal, o paciente foi classificado como portador de doen√ßa card√≠aca. Caso contr√°rio, o paciente n√£o foi diagnosticado com a doen√ßa. 

| Vari√°vel | Descri√ß√£o
| -------- | ---------
| age_sex  | Idade - Sexo
| cp       | Tipo de dor no peito
| trestbps | Press√£o sangu√≠nea (mm Hg) em descanso
| chol     | Colesterol (mg/dl)
| fbs      | A√ß√∫car no sangue em jejum maior do que 120mg/dl (1 = Sim, 0 = N√£o)
| restecg  | Resultados eletrocardiogr√°ficos em repouso
| thalach  | Maior ritmo card√≠aco atingido
| exang    | Angina induzida por exerc√≠cio
| ca       | N√∫mero de vasos principais coloridos por _flourosopy_
| target   | Diagn√≥stico de doen√ßa card√≠aca (1 = Sim, 0 = N√£o)

Vamos come√ßar, ent√£o?

- [Download do Banco](https://github.com/p4hUSP/material-bio/raw/master/docs/data/heart_modificado.xlsx)


O banco hoje est√° em formato Excel. Voc√™ sabe qual fun√ß√£o e pacote utilizamos para abrir esse arquivo?


```{r}
library(<pacote>)

banco <- <funcao>(<caminho_do_arquivo>)
```

## 1. tidyr

O `tidyr` √© o pacote utilizado para estruturar os nossos bancos de dados. Em geral, ele pode ser utilizado para __unir__ (`unite`) e __separar__ (`separate`) colunas ou para __derreter__ (`gather`) e __esticar__ (`spread`) as colunas. 

Esse pacote √© constru√≠do com base no conceito de `tidy data`. Deixar os seus dados `tidy` significa transformar a __estrutura__ deles de tal maneira que tenhamos observa√ß√µes nas linhas, vari√°veis nas colunas e valores nas c√©lulas. Em geral, esperamos tamb√©m que um banco `tidy` contenha apenas uma unidade de observa√ß√£o, granularidade, etc.

![](imgs/r_tidy_data.png)
<center>
Ilustra√ß√£o do Tidy Data (Fonte: http://statseducation.com)
</center>

!!! question \" O que √© unidade de observa√ß√£o / granularidade? \"

    Trata-se da unidade contida nas linhas do seu banco. Por exemplo, se montarmos um banco de dados com 
    informa√ß√µes sobre __pessoas__ (altura, idade, peso, etc.) em cada linha teremos __pessoas__ como unidade de 
    observa√ß√£o.
    Qual a unidade de observa√ß√£o do nosso banco?

### 1.1 separate()

!!! warning \" Instalando pacotes \"

    Caso voc√™ n√£o tenha o `tidyr` ou o `tibble`no seu computador, por favor, execute o c√≥digo `install.packages(c('tidyr', 'tibble'))`.

`separate()` √© uma fun√ß√£o do pacote `tidyr` que tem como objetivo __separar__ valores contidos em uma coluna. √Äs vezes, mais de uma informa√ß√£o √© agrupado dentro da mesma vari√°vel. Repare no exemplo abaixo.


```{r}
exemplo_separete <- tibble::tribble(
  ~ CIDADE , ~MORTALIDADE,
  'S√£o Jos√© dos Campos - SP', 80,
  'Porto Alegre - RS', 100,
  'Bras√≠lia - DF', 81
)

exemplo_separete
```

Qual vari√°vel cont√©m mais de uma informa√ß√£o? Por mais que talvez voc√™ tenha o costume de agrupar a sua cidade √† unidade federativa dela, esses dois valores dizem respeito a qualidades diferentes da nossa oberva√ß√£o. Imagine que o banco se estendesse para todas as cidades brasileiras. Como far√≠amos para identificar as unidades federativas com maior m√©dia de mortalidade?

Como aplicar a fun√ß√£o `separate()`? Antes de tudo, tente executar o comando `?separate`. A documenta√ß√£o do `tidyr` tende a ser muito boa e normalmente teremos uma boa explica√ß√£o de como a fun√ß√£o opera e de quais par√¢metros precisamos utilizar nela.

No caso, o `separate()` recebe (1) no primeiro par√¢metro o banco de dados, (2) no segundo, a coluna que desejamos separar, (3) na terceira o nome das colunas que desejamos criar a partir da coluna informada no segundo par√¢metro, (4) o separador, ou seja, o padr√£o de caracteres que ser√£o utilizados para separar a coluna do segundo par√¢metro nas colunas especificadas no terceiro par√¢metro. Isso pode parecer complicado, mas √© bem simples.

```r
separate(<dataframe>, <coluna_que_desejamos_separar>, <vetor_com_as_colunas_a_serem_criadas>, <separador>)
```

Tente fazer sozinho.

<br/>


<br/>

- __Reposta__:

```r
separate(exemplo_separete, 'CIDADE', c('CIDADE', 'UF'), '-')
```

#### 1.1.1. Aplicando no nosso banco

Voc√™ consegue descobrir qual vari√°vel no nosso banco tem esse problema?

!!! question \" Fun√ß√µes para explorar dataframes \"

    Tente utilizar fun√ß√µes para explorar o seu dataframe. Por exemplo, com `head()` conseguimos obter facilmente
    as primeiras linhas do nosso banco.

Voc√™ percebeu alguma coisa de estranho na vari√°vel `age_sex`? O que? 

`age_sex` cont√©m dois tipos de informa√ß√µes diferentes. De um lado, temos a idade da pessoa. Do outro, temos o sexo dessa pessoa. Novamente, precisamos separar essas __duas__ informa√ß√µes em __duas__ vari√°veis para que possamos prosseguir com a nossa an√°lise.

Vamos l√°? Agora √© a sua vez. Como precisamos fazer para separar as duas vari√°veis? üí™

PS: N√£o se preocupe com o `remove = FALSE`. Utilizamos esse par√¢metro apenas para manter a vari√°vel antiga e sermos capazes de validar o nosso resultado.

```r
separate(<banco>, <variavel>, <vetor>, <sep>, remove = FALSE)
```

Que tal dar um `View()` no seu banco agora?

```r
View(banco)
```

!!! warning \" Salvando altera√ß√µes \"

    Nunca se esque√ßa de que o R n√£o sabe que voc√™ deseja sobrescrever uma vari√°vel. Ao contr√°rio do Stata, por exemplo, as altera√ß√µes devem ser escritas sobre uma vari√°vel com `<-`. Caso contr√°rio, o R ir√° apenas imprimir no console o resultado.

<br/>

Agora, podemos utilizar o `View()` ou o `head()` para verificar se deu tudo certo.
  
### 1.2. `unite`
  
A fun√ß√£o `unite()` tem o comportamento inverso `separate()`. N√≥s a utilizamos para unir valores que fazem mais sentido juntos do que separados. Repare no exemplo abaixo. O que voc√™ faria para obter em uma √∫nica vari√°vel uma informa√ß√£o mais precisa?

```{r}
exemplo_unite <- tibble::tribble(
  ~ID,~DIA, ~MES, ~ANO, ~DOSE_REMEDIO, ~RESULTADO,
  1, 14, 8, 2018, 1, 0,
  1, 15, 8, 2018, 2, 0,
  2, 9, 7, 2018, 1 ,0,
  2, 10, 7, 2018, 2, 0,
  2, 11, 7, 2018, 3, 1
)

exemplo_unite
```

Ap√≥s executar o c√≥digo acima, vamos prosseguir com a fun√ß√£o `unite()`. Ela recebe (1) no primeiro par√¢metro o banco de dados e (2) no segundo o nome da __nova__ vari√°vel. Em seguida, (3) adicionamos todas as colunas que queremos concatenar (4) e, por fim, podemos escolher o separador entre as colunas.

```r
unite(<banco>, <nome_da_nova_variavel>, sep = '<separador>')
```

Vamos tentar sozinho primeiro?

<br/>

<br/>

- __Resposta__:

```{r}
banco <- unite(exemplo_unite, "DATA", ANO, MES, DIA, sep = "-")
```

Verifique o resultado com a fun√ß√£o `head()`.

#### 1.2.1. Aplicando no nosso banco

Que tal arrumar, agora, o nosso banco de dados tamb√©m? Lembre-se que √© poss√≠vel utilizar a as fun√ß√µes `head()`, `str()`, entre outras para ter uma ideia geral da estrutura do nosso `dataframe`.

Provavelmente, voc√™ reparou que existem tr√™s vari√°veis que, na verdade, fornam uma √∫nica: `birth_day`, `birth_month` e `birth_year`. Que tal tentar uni-las com a fun√ß√£o `separate()`?

## 2. Exerc√≠cios - Parte 1

N√≥s acabamos de aprender a __estruturar__ o nosso banco no que diz respeito a __unir__ e __separar__ vari√°veis. Vamos praticar mais um pouco?

### 2.1. Exerc√≠cio - Exemplos de `unite` e `separate`

Para cada tabela abaixo (1) diga se √© necess√°rio realizar um `unite()` ou um `separate()` e (2) escreva o c√≥digo que corrija esse problema.

- __Item I__:

```{r}
ex2_1_1 <- tibble::tribble(
  ~ANO, ~RAZAO_DE_HOMICIDIO,
  2014, '1200293 / 102000000',
  2015, '201992 / 102929222',
  2016, '203918 / 175999271',
  2017, '2901827 / 228191900',
  2018, '201928 / 201928238', 
)
```

- __Item II__:

```{r}
ex_2_1_2 <- tibble::tribble(
  ~NOME, ~LOGRADOUR, ~NUMERO, ~COMPLEMENTO,
  'Lyandra', 'Rua Ademar de Barros', 20, 'APT 28',
  'Monica', 'Avenida S√£o Pedro', 30, 'BLOCO A',
  'Luis', 'Rua do Lago', 22, 'Port√£o do lado esquerdo',
  'Isaac', 'Avenida Paulista', 22, 'APT 102',
  'S√¥nia', 'Rua Brigadeiro', 982, 'APT 283'
)
```

- __Item III__:

```{r}
ex_2_1_3 <- tibble::tribble(
  ~ID, ~DIA, ~MES, ~ANO, ~ALTURA_PESO,
  1, 10, 2, 1998, '180 - 340',
  2, 11, 2, 1998, '190 - 200',
  3, 20, 3, 1998, '188 - 176',
  2, 30, 5, 1998, '192 - 180'
)
```


Parab√©ns! :tada: :tada: :tada:

## 3. Gather e Spread

Voc√™ j√° ouviu falar em bancos no formato `wide` e `long`? 

<center>

__Mortalidade na China e no Brasil - Wide__ 

</center>
<center>
| Pa√≠s | 2015 | 2016
| ---- | ---- | ----
| Brasil | 12 | 12.2
| China | 20 | 30

</center>

<center>

__Mortalidade na China e no Brasil - Long__ 

</center>
<center>
| Pa√≠s | Ano | Mortalidade
| ---- | ---- | ----
| Brasil | 2015 | 12
| Brasil | 2016 | 12.2
| China | 2015 | 20
| China | 2016 | 30
</center>

Qual a diferen√ßa entre os dois bancos? Quais deles est√° no formato `tidy`? Se poss√≠vel escreva ou tente explicar em voz alta.

<br/>

Como o primeiro banco n√£o cont√©m apenas uma oberva√ß√£o por linha, ele __n√£o__ √© `tidy`. Voc√™ concorda que as tomadas de dados sobre mortalidade sobre dois anos n√£o podem ocorrer simultaneamente no mesmo ano? Al√©m disso, `2015` e `2016` est√£o ocupando a posi√ß√£o de vari√°veis, mas elas na verdade s√£o valores de uma outra vari√°vel? Voc√™ sabe dizer qual?

O exemplo de banco `tidy` √© o segundo. Nele, temos as vari√°veis claramente denominadas no cabe√ßalho do nosso banco. `Pa√≠s` √© uma vari√°vel, assim como `Ano` e `Mortalidade`. E cada linha possui uma √∫nica observa√ß√£o.

Que fique bem claro: `tidy` n√£o √© uma defini√ß√£o de qualidade do banco. Apenas tentamos _estruturar_ a nossa tabela nesse formato porque isso torna mais f√°cil a intera√ß√£o com outras fun√ß√µes (ex. `dplyr`, `ggplot`, etc.).

### 3.1. `gather()`

`gather()` √© utilizado para derreter/agrupar as colunas dos nossos bancos. Pensando no exemplo anterior, essa fun√ß√£o transforma o nosso banco _wide_ em um banco _long_.

```{r}
tabela_wide <- tibble::tribble(
  ~Pa√≠s , ~`2015`, ~`2016`,
  'Brasil' , 10.2 , 11.2,
  'China' , 14.3 , 18.4,
)

tabela_wide
```

`gather()` recebe (1) o banco de dados, (2) o nome da vari√°vel (`key`) que est√° como nome das colunas, (3) o nome da vari√°vel que est√° nas c√©lulas, (4) os nomes das colunas em que iremos realizar a opera√ß√£o __sem aspas__.

```r
gather(<banco>, <key>, <value>, <VAR1>, <VAR2>, <VARn>)
```

Dado isso, qual c√≥digo devemos utilizar para realizar a transforma√ß√£o em `tabela_wide`.

<br/>

- __Resposta__:

```{r}
gather(tabela_wide, key = 'ano', value = 'mortalidade' ,`2015`, `2016`)
```

#### 3.1.1. Aplicando

Como o nosso banco n√£o possui esse problema, vamos fingir que decidimos realizar uma segunda coleta de dados e queremos avaliar a evolu√ß√£o de doen√ßas card√≠acas nossos pacientes ap√≥s 1 ano. Por√©m, o seu estagi√°rio era pregui√ßoso e ao inv√©s de estruturar o seu banco no formato `tidy` ele (1) alterou o nome da coluna `target` para `target2018` e (2) criou uma coluna `target2019` para os novos resultados
 
```{r}
ex3_1_1 <- tibble::tribble(
  ~ID, ~target2018, ~target2019,
  1, 0, 0,
  2, 1, 1,
  3, 1, 1,
  4, 1, 1,
  5, 1, 0,
)

ex3_1_1
```

Qual c√≥digo seria utilizado para deixar essa tabela `tidy`?

### 3.2. `spread()`

`spread()` realiza a opera√ß√£o inversa do `gather()`. Ela estica os nossos dados horizontalmente. Mas isso n√£o acaba com o formato `tidy` do nosso banco? Sim, mas lembre-se que apenas estruturamos os nossos dados de acordo com os princ√≠pios do `tidy data` porque a maior parte das fun√ß√µes esperam esse tipo de estrutura! Isso n√£o significa que ao apresentar uma tabela para algu√©m ela deva estar no formato `tidy`. Ela simplesmente deve estar na maneira mais intuitiva de ler.

```{r}
tabela_long <- tibble::tribble(
  ~pais, ~ano, ~mortalidade,
  'Brasil' , 2015 , 10.2,
  'Brasil' , 2016 , 11.2,
  'China' , 2015 , 14.3,
  'China' , 2016 , 18.4,
)

tabela_long
```

A fun√ß√£o `spread()` recebe os seguintes par√¢metros: (1) Primeiro, precisamos fornecer o banco de dados; (2) em segundo lugar, o nome da vari√°vel cujo os valores ser√£o dispostos como colunas; (3) por fim, a vari√°vel que fornecer√° os valores para as c√©lulas. S√£o os mesmos par√¢metros da fun√ß√£o `gather()`!

```r
spread(<banco>, <key>, <value>)
```

Como voc√™ faria para deixar o pa√≠s na linha e os anos no cabe√ßalho com os valores de mortalidade ocupando o centro da tabela?

<br/>

<br/>

- __Resposta__:

```{r}
spread(tabela_long, ano, pib)
```

#### 3.2.1. Aplicando no nosso banco

Por favor, execute o c√≥digo abaixo. N√£o se preocupe em entender como ele funciona. N√≥s veremos isso na pr√≥xima aula. Tenha apenas em mente que ele retorna a quantidade de observa√ß√µes diagnosticadas com doen√ßa card√≠aca entre homens e mulheres.

```{r}
ex3_1_1 <- banco %>% 
  group_by(sex, target) %>%
  summarise(n = n())

ex3_1_1
```

Ser√° que essa √© a melhor maneira de visualizar esse resultado? Ainda que voc√™ consiga extrair alguma informa√ß√£o, imagine se tiv√©ssemos 3 ou 4 categorias em cada vari√°vel. Provavelmente, n√£o seria t√£o f√°cil. Uma maneira elegante de resolver esse problema √© com a fun√ß√£o `spread()`. Como voc√™ aplicaria essa fun√ß√£o para que a vari√°vel `target` fique no cabe√ßalho?

## 4. Exerc√≠cios - Parte 2

### 4.1. Exerc√≠cio - `spread()`

Apresente a tabela abaixo de tal maneira que as UFs fiquem nas linhas e o n√≠vel de escolaridade esteja distribu√≠do pelas colunas.

- __Item I__:

```{r}
ex_4_1_1 <- tibble::tribble(
  ~UF, ~mes, ~nivel_escolaridade,
  'SP', 'Jan', 20.2,
  'SP', 'Fev', 29.2,
  'SP', 'Mar', 12.3,
  'SP', 'Abr', 14.3,
  'RJ', 'Jan', 28.2,
  'RJ', 'Fev', 19.2,
  'RJ', 'Mar', 9.3,
  'RJ', 'Abr', 30.3,
)
```

- __Item II__:

```{r}
ex_4_1_2 <- tibble::tribble(
  ~pais, ~ano, ~venda,
  'Brasil', 2014, 20.2,
  'Brasil', 2015, 29.2,
  'Brasil', 2016, 12.3,
  'Brasil', 2017, 14.3,
  'Col√¥mbia', 2014, 28.2,
  'Col√¥mbia', 2015, 19.2,
  'Col√¥mbia', 2016, 9.3,
  'Col√¥mbia', 2017, 30.3,
)
```

### 4.2. Exerc√≠cio - `gather()`

Transforme as pr√≥ximas tabelas em `tidy data`.

- __Item I__: Escolaridade:

```{r}
ex_4_2_1 <- tibble::tribble(
  ~pais, ~`Jan`, ~`Fev`,
  'China', 92, 20.2,
  'EUA', 10.2, 42,
  'Fran√ßa', 72.2, 26,
  'Chile', 80.2, 90,
  'Jap√£o', 19.1, 25,
)
```

- __Item II__: Mortes por arma de fogo

```{r}
ex_4_2_2 <- tibble::tribble(
  ~UF, ~`2015`, ~`2016`,
  'SP', 92, 20.2,
  'RJ', 10.2, 42,
  'RS', 72.2, 26,
  'CO', 80.2, 90,
  'PE', 19.1, 25,
)
```

## 4. `dplyr`

Dentre os pacotes mais importantes do `tidyverse`, o `dplyr` se destaca. Ele traz uma biblioteca pode rasa de fun√ß√µes que nos permitem transformar dados. Essa √© a tarefa que voc√™ provavelmente passar√° mais tempo fazendo j√° que nem sempre os dados est√£o limpos. Muitas vezes teremos que criar vari√°veis ou extrair parte da informa√ß√£o presente em uma antes de rodarmos um modelo.

Quais s√£o os verbos do `dplyr`? Obviamente, o pacote √© extenso e possui uma quantidade razo√°vel de fun√ß√µes, mas queremos que voc√™ se atente, agora, a tr√™s fun√ß√µes: `select()`, `filter()`, `mutate()`.

### 4.1. `select()`

O `select()` √© capaz de selecionar colunas espec√≠ficas do nosso banco de dados. O uso dela √© bem simples e precisamos apenas escrever as vari√°veis que desejamos selecionar __sem aspas__. Caso voc√™ deseje __excluir__ uma vari√°vel, acrescente um `-` antes do no nome. Assim como nas fun√ß√µes do `tidyr` (`gather()`, `spread()`, etc.), informamos o banco de dados no primeiro par√¢metro de nossa fun√ß√£o.

```r
select(<banco>, <VAR1>, <VAR2>, -<VAR3>)
```

Repare que antes de `<VAR3>` n√≥s adicionamos um `-`. Isso significa que queremos excluir essa coluna no banco

Imagine que ap√≥s muita pesquisa, voc√™ tenha descoberto que a melhor vari√°vel para _prever_ doen√ßas card√≠acas seja idade (`age`). Como voc√™ faria para selecionar apenas `target` e `age`?

<br/>

<br/>

- __Resposta__:

```{r}
select(banco, age, target)
```

Agora, imagine que tenha sido provado que sexo √© irrelevante. Como voc√™ faria para excluir essa vari√°vel do banco?

<br/>

<br/>

```{r}
select(banco, -sex)
```

### 4.2. `filter()`

Novamente, o nome da fun√ß√£o j√° entrega o objetivo dela. `filter()` filtra (d√£√£) as __observa√ß√µes__ da nossa tabela por meio de `opera√ß√µes booleanas`.

!!! question \" Operadores l√≥gicos \"

    N√≥s vimos na primeira aula que operadores l√≥gicas s√£o opera√ß√µes que retornam 
    necessariamente apenas dois resultados: verdadeiro e falso. A partir de agora, come√ßaremos a
    utilizar eles cada vez mais. Ent√£o, se n√£o estiver se sentindo confort√°vel com o tema, volte
    para a primeira aula e reveja os exemplos.
    
Como ela funciona? Simples, voc√™ apenas precisa realizar um teste de verdadeiro e falso a partir de uma vari√°vel do seu banco.

```r
filter(<banco>, <operacao_booleana>)
```

Repare no banco abaixo. Como voc√™ faria para selecionar as observa√ß√µes de `SP`? 

```{r}
exemplo_filter <- tibble::tribble(
  ~UF, ~`2015`, ~`2016`,
  'SP', 92, 20.2,
  'RJ', 10.2, 42,
  'RS', 72.2, 26,
  'CO', 80.2, 90,
  'PE', 19.1, 25,
)

exemplo_filter
```

Qual o operador l√≥gico que testa igualdade? Se voc√™ pensou no `==`, acertou! :tada: Agora, s√≥ precisamos coloc√°-lo dentro do `filter()` e deixar que m√°gica aconte√ßa.

<br/>

<br/>

- __Resposta__:

```{r}
filter(exemplo_filter, UF == 'SP')
```

### 4.3. `mutate()`

`mutate()` nos permite transformar e criar colunas em nossa tabela de maneira r√°pida e intuitiva. Repare na tabela abaixo.

```{r}
exemplo_mutate <- tibble::tribble(
  ~UF, ~mes, ~total, ~homi
  'SP', 'Jan', 20.2, 3
  'SP', 'Fev', 29.2, 4
  'SP', 'Mar', 12.3, 6
  'SP', 'Abr', 14.3, 4
  'RJ', 'Jan', 28.2, 3
  'RJ', 'Fev', 19.2, 3
  'RJ', 'Mar', 9.3, 10
  'RJ', 'Abr', 30.3, 20
)
```

Sento `total` o total de mortes registradas naquele m√™s e `homi` valor absoluto de homic√≠dios, √© poss√≠vel retirar a taxa de homic√≠dios entre todas as outras mortes realizando com a opera√ß√£o de divis√£o.

```r
mutate(<banco>,
       <variavel> = <operacao>)
```

Novamente, o banco de dados √© fornecido como primeiro par√¢metro. A diferen√ßa √© que dessa vez iremos fazer refer√™ncias a vari√°veis (`<variavel>`) dentro da fun√ß√£o `mutate()` para alter√°-las. Em `<operacoes>`, voc√™ pode fazer refer√™ncia a outras vari√°veis do banco ou at√© mesmo de outros objetos para realizar a sua conta.

Voc√™ consegue imaginar como escrever o c√≥digo acima para retirar a taxa de homic√≠dios?