---
title: "Estruturar"
author: "P4H"
output: md_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12,
                      fig.height=8,
                      warning=FALSE,
                      message=FALSE,
                      eval=FALSE)
```

## 1. tidyr

O `tidyr` √© o pacote utilizado para estruturar os nossos bancos de dados. Em geral, ele pode ser utilizado para __unir__ (`unite`) e __separar__ (`separate`) colunas ou para __derreter__ (`gather`) e __esticar__ (`spread`) as colunas. 

Esse pacote √© contru√≠do com base no conceito de `tidy data`. Deixar o seus dados `tidy` significa transformar a __estrutura__ dos dados de tal maneira que tenhamos observa√ß√µes nas linhas, vari√°veis nas colunas e valores nas c√©lulas. Em geral, esperamos tamb√©m que um banco `tidy` contenha apenas uma unidade de observa√ß√£o, granularidade, etc.

![](imgs/r_tidy_data.png)
<center>
Ilustra√ß√£o do Tidy Data (Fonte: http://statseducation.com)
</center>

!!! question \" O que √© unidade de observa√ß√£o / granularidade? \"

    Trata-se da unidade contida nas linhas do seu banco. Por exemplo, se montarmos um banco de dados com 
    informa√ß√µes sobre __pessoas__ (altura, idade, peso, etc.) em cada linha teremos __pessoas__ como unidade de 
    observa√ß√£o.
    
    Tente imaginar a unidade de observa√ß√£o de informa√ß√µes como PIP, desemprego, entre outras coisas.s

### 1.1 separate

- [Download do Banco](https://github.com/p4hUSP/material-bio/raw/master/docs/data/ramen-ratings.zip)

Vamos come√ßar abrindo o nosso banco. Repare que j√° estamos carregando o pacote `tidyr`.

!!! warning \" Instalando pacotes \"

    Caso voc√™ n√£o tenha o `tidyr` no seu computador, por favor, execute o c√≥digo `install.packages('tidyr')`.

```{r}
library(readr)
library(tidyr)

banco <- read_csv('data/ramen-ratings.zip')
```

`separate()` √© uma fun√ß√£o do pacote `tidyr` que tem como objetivo __separar__ valores contidos em uma coluna. √Äs vezes, mais de uma informa√ß√£o √© agrupado dentro da mesma coluna. Voc√™ consegue identificar no nosso banco de dados em qual coluna isso acontece?

!!! question \" Fun√ß√µes para explorar dataframes \"

    Tente utilizar fun√ß√µes para explorar o seu dataframe. Por exemplo, com `head()` conseguimos obter facilmente
    as primeiras linhas do nosso banco. Experiemente utilizar `table()` dessa vez j√° que o banco possu√≠ uma quantidade 
    razo√°vel de vari√°veis categ√≥ricas.

Voc√™ percebeu alguma coisa de estranho na vari√°vel `Top Ten`? O que? Se voc√™ percebeu que na verdade ela cont√©m duas vari√°veis, parab√©ns! :tada: Agora temos um exemplo para usarmos a fun√ß√£o `separate()`.

Como o `separate()` funciona? Tente executar o comando `?separate`. A documenta√ß√£o do `tidyverse` tende a ser muito boa e normalmente teremos uma boa explica√ß√£o de como a fun√ß√£o opera e de quais par√¢metros precisamos utilizar nela.

No caso, o `separate()` recebe (1) no primeiro par√¢metro o banco de dados, (2) no segundo, a coluna que desejamos separar, (3) na terceira o nome das colunas que desejamos criar a partir da coluna informada no segundo par√¢metro, (4) o separador, ou seja, o padr√£o de caracteres que ser√£o utilizados para separar a coluna do segundo par√¢metro nas colunas espec√≠ficadas no terceiro par√¢metro. Isso pode parecer complicado, mas √© bem simples.

```r
separate(<dataframe>, <coluna_que_desejamos_separar>, <vetor_com_as_colunas_a_serem_criadas>, <separador>)
```

Vamos l√°? üí™

```{r}
separate(banco, 'Top Ten', c('top_year', 'top_position'), '#', remove = FALSE)
```

Que tal dar um `View()` no seu banco agora?

```r
View(banco)
```

!!! warning \" Salvando altera√ß√µes \"

    Nunca se esque√ßa de que o R n√£o sabe que voc√™ deseja sobrescrever uma vari√°vel. Ao contr√°rio do Stata, por exemplo, as altera√ß√µes devem ser escritas sobre uma vari√°vel com `<-`. Caso contr√°rio, o R ir√° apenas imprimir no console o resultado.

<br/>
    
```{r}
banco <- separate(banco, 'Top Ten', c('top_year', 'top_position'), '#', remove = FALSE)
```  

Agora, podemos utilizar o `View()` ou o `head()` para verificar se deu tudo certo.
  
### unite
  
A fun√ß√£o `unite()` faz o oposto da `separate()`. O nome dela j√° entrega o objetivo dela, que √© __unir__ ou __concatenar__ colunas. Um dos melhores exemplos de uso dessa fun√ß√£o √© unir as vari√°veis de `dia`, `m√™s` e `ano`. Como n√£o temos essa informa√ß√£o no nosso banco, vamos adicionar algumas datas de mentira.

```r
set.seed(12345)

banco$fake_dia <- replicate(nrow(banco), sample(1:28, 1))
banco$fake_mes <- replicate(nrow(banco), sample(1:12, 1))
banco$fake_ano <- replicate(nrow(banco), sample(2002:2016, 1))
```

Ap√≥s executar o c√≥digo acima, vamos prossguir com a fun√ß√£o `unite()`. Ela recebe (1) no primeiro par√¢metro o banco de dados e (2) no segundo o nome da __nova__ vari√°vel. Em seguida, (3) podemos adicionar os nodemos de todas as colunas que queremos concatenar (4) e, por fim, podemos escolher o separador entre as colunas.

```{r}
banco <- unite(banco, "data", fake_ano, fake_mes, fake_dia, sep = "-")
```

Virique o resultado com a fun√ß√£o `head()`.

## Exerc√≠cios - Parte 1

### Exerc√≠cio - Exemplos de `unite` e `separate`

Para cada tabela abaixo diga se √© necess√°rio realizar um `unite()` ou um `separate()`. Em seguinda, escreva o c√≥digo que voc√™ utilizaria.

<br/>

<center>
CIDADE | PIB   |
 ----- | ------|
"S√£o Jos√© dos Campos - SP"| 19.2|
"S√£o Paulo - SP"| 20 |
"Porto Alegre - RS"| 8.2 |
</center>

<br/>

<center>
CIDADE | ALUNOS - ESCOLAS   |
 ----- | ------|
S√£o Jos√© dos Campos | 19292 - 1882
S√£o Paulo | 21828 - 102
Porto Alegre | 102761 - 98 |
</center>


<br/>

Nesse √∫ltimo exemplo, imagine que estamos preparando um banco para realizar uma pesquisa de endere√ßos no Google.

<center>
CIDADE | RUA | NUMERO
 ----- | ------|
Ubatuba | Rua das Pedras | 29
Uberl√¢ndia | Avenida Minas Geras | 20002
Curitiba | Rua dos Cocais | 10002
</center>

## Exerc√≠cio - unite() e separate() na pr√°tica

1. Aplique a fun√ß√£o `unite()` nas colunas `Style` e `Country`.

2. Aplique a fun√ß√£o `separate()` na coluna criada no exerc√≠cio anterior


## 3. Gather e Spread

Voc√™ j√° ouviu falar em bancos no formato `wide` e `long`? No geral, existem duas maneiras de organizar s√©ries temporais. Quando optamos pelo `wide`, o nosso banco √© "esticado" horizontalmente; enquanto, quanto a op√ß√£o √© pelo `long`, o banco √© "esticado" verticalmente.

<center>

__PIB na China e no Brasil - Wide__ 

</center>
<center>
| Pa√≠s | 2015 | 2016
| ---- | ---- | ----
| Brasil | 10.2 | 11.2
| China | 14.3 | 18.4

</center>

<center>

__PIB na China e no Brasil - Long__ 

</center>
<center>
| Pa√≠s | Ano | PIB
| ---- | ---- | ----
| Brasil | 2015 | 10.2
| Brasil | 2016 | 11.2
| China | 2015 | 14.3
| China | 2016 | 18.4

</center>

### 3.1. `gather()`

`gather()` √© utilizado para derreter/agrupar as colunas dos nossos bancos. Essa fun√ß√£o recebe (1) o banco de dados, (2) o nome da vari√°vel que est√° como nome das colunas, (3) o nome da vari√°vel que est√° nas c√©lulas, (4) os nomes das colunas em que iremos realizar a opera√ß√£o __sem aspas__.

Ela pode parecer um pouco complicada de se utilizar do que o `unite()` e o `separate()`, mas com um pouco de pr√°tica ela se torna bastante intuitiva. Para quem est√° acostumado com o Excel, estamos fazendo uma `tabela din√¢mica` ou `pivot table`. 

```{r}
tabela_wide <- tibble::tribble(
  ~Pa√≠s , ~`2015`, ~`2016`,
  'Brasil' , 10.2 , 11.2,
  'China' , 14.3 , 18.4,
)

gather(tabela_wide, key = 'ano', value = 'pib' ,`2015`, `2016`)
```

### 3.2. `spread()`

A fun√ß√£o `spread()` realiza a opera√ß√£o inversa. Ela estica os nossos dados horizontalmente. Mas isso n√£o acaba com o formato `tidy` do nosso banco? Sim, mas lembre-se que apenas estruturamos os nossos dados de acordo com os princ√≠pios `tidy` porque a maior parte das fun√ß√µes esperam esse tipo de estrutura! Isso n√£o significa que essa √© a melhor maneira de, por exemplo, apresentar os nossos dados.

A fun√ß√£o `spread()` recebe par√¢metros bem parecidos como a `gather()`. (1) Primeiro, precisamos fornecer o banco de dados; (2) em segundo lugar, o nome da vari√°vel cujo os valores ser√£o dispostos como colunas; (3) por fim, a vari√°vel que fornecer√° os valores para as c√©lulas.

```{r}
tabela_long <- tibble::tribble(
  ~pais, ~ano, ~pib,
  'Brasil' , 2015 , 10.2,
  'Brasil' , 2016 , 11.2,
  'China' , 2015 , 14.3,
  'China' , 2016 , 18.4,
)

spread(tabela_long, ano, pib)

```

## Exerc√≠cios - Parte 2

### Exerc√≠cio - `spread()`

Apresente a tabela abaixo de tal maneira que as UFs fiquem nas linhas e o nivel de escolaridade esteja distribu√≠do pelas colunas.

```{r}
tabela_escolaridade <- tibble::tribble(
  ~UF, ~mes, ~nivel_escolaridade,
  'SP', 'Jan', 20.2,
  'SP', 'Fev', 29.2,
  'SP', 'Mar', 12.3,
  'SP', 'Abr', 14.3,
  'RJ', 'Jan', 28.2,
  'RJ', 'Fev', 19.2,
  'RJ', 'Mar', 9.3,
  'RJ', 'Abr', 30.3,
)
```

Fa√ßa a mesma coisa agora com a tabela abaixo e deixe o pa√≠s nas linhas.

```{r}
tabela_pais <- tibble::tribble(
  ~pais, ~ano, ~venda,
  'Brasil', 2014, 20.2,
  'Brasil', 2015, 29.2,
  'Brasil', 2016, 12.3,
  'Brasil', 2017, 14.3,
  'Colombia', 2014, 28.2,
  'Colombia', 2015, 19.2,
  'Colombia', 2016, 9.3,
  'Colombia', 2017, 30.3,
)
```

### Exerc√≠cio - `gather()`

Transforme as pr√≥ximas tabelas em formato `tidy`.

- Escolaridade:

```{r}
tabela_pais_escol <- tibble::tribble(
  ~pais, ~`Jan`, ~`Fev`,
  'China', 92, 20.2,
  'EUA', 10.2, 42,
  'Fran√ßa', 72.2, 26,
  'Chile', 80.2, 90,
  'Jap√£o', 19.1, 25,
)
```

- Mortes por arma de fogo

```{r}
tabela_arma_fogo <- tibble::tribble(
  ~UF, ~`2015`, ~`2016`,
  'SP', 92, 20.2,
  'RJ', 10.2, 42,
  'RS', 72.2, 26,
  'CO', 80.2, 90,
  'PE', 19.1, 25,
)
```

## 4. `dplyr`

Dentre os pacotes mais importantes do `tidyverse`, o `dplyr` se destaca. Ele traz uma biblioteca poderasa de fun√ß√µes que nos permitem transformar dados. Essa √© a tarefa que voc√™ provavelmente passar√° mais tempo fazendo j√° que nem sempre os dados est√£o limpos. Muitas vezes teremos que criar vari√°veis ou extrair parte da informa√ß√£o presente em uma para que possas rodar um modelo.

Quais s√£o os verbos do `dplyr`? Obviamente, o pacote √© extenso e possui uma quantidade razo√°vel de fun√ß√µes, mas queremos que voc√™ se atente, agora, a tr√™s fun√ß√µes: `select()`, `filter()`, `mutate()`.

### 4.1. `select()`

O `select()` √© capaz de selecionar colunas espec√≠ficas do nosso banco de dados.

Vamos carregar novamente o banco de _ramen_.

```{r}
library(dplyr)
library(readr)

banco <- read_csv('data/ramen-ratings.zip')
```

Digamos que seja mais relevante apresentar apenas as vari√°veis `Brand` e `Stars`.

```{r}
select(banco, Brand, Stars)
```

Parece bem simples, n√£o? Repare apenas que n√£o colocamos aspas nos nomes das vari√°veis dentro do `select()`. Isso √© uma coisa um pouco ruim do `tidyverse` j√° que √†s vezes precisamos colocar as aspas e √†s vezes n√£o. Fique atento para n√£o errar isso e caso tenha d√∫vidas d√™ uma olhada na documenta√ß√£o da fun√ß√£o com `?select`.

### 4.2. `filter()`

Novamente, o nome da fun√ß√£o j√° entrega o objetivo dela. `filter()` filtra (d√£√£) as __observa√ß√µes__ da nossa tabela. Digamos que voc√™ esteja de viagem para o Jap√£o e que queira olhar apenas as avalia√ß√µes desse pa√≠s. Para obter esse resultado, voc√™ ter√° que fazer uso dos `operadores l√≥gicas`

!!! question \" Operadores l√≥gicos \"

    N√≥s vimos na primeira aula que operadores l√≥gicas s√£o opera√ß√µes que retornam 
    necessariamente apenas dois resultados: verdadeiro e falso. A partir de agora, come√ßaremos a
    utilizar eles cada vez mais. Ent√£o, se n√£o estiver se sentindo confort√°vel com o tema, volte
    para a primeira aula e reveja os exemplos.
    
    
Qual o operador l√≥gico que testa igualdade? Se voc√™ pensou no `==`, acertou! :tada: Agora, s√≥ precisamos coloc√°-lo dentro do `filter()` e deixar que m√°gica aconte√ßa. Assim como nas outras fun√ß√µes, (1) o primeiro argumento √© o banco de dados. (2) O segundo, no caso, √© o teste que queremos realisar. Repare que `filter()` ir√° retornar todos os valores que tiverem como resposta para o teste o valor `TRUE`. Logo, no exemplo abaixo, ser√£o retornados todas as observa√ß√µes em que `Country` seja igual a `Japan`.

```{r}
filter(banco, Country == 'Japan')
```

### 4.3. `mutate()`

Essa fun√ß√£o ser√° de longe uma das mais utilizadas caso voc√™ tenha que trabalhar com o R. Ela traz uma maneira bastante intuitiva de criar e alterar vari√°veis.


