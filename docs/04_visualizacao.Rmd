---
title: "Visualizacao"
author: "P4H"
output: md_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12,
                      fig.height=8,
                      warning=FALSE,
                      message=FALSE,
                      eval=FALSE)
```

As visualizações gráficas são muito importantes para transmitir informações. Podemos dizer até que ela é fundamental para análise de dados, nos ajudando a responder questões, tomar decisões, contar histórias e até mesmo inspirar. Veremos não só como fazer estas visualizações, mas também a entender quando elas podem ser necessárias.

Além disso, vamos aproveitar para rever alguns tópicos de aulas passadas utilizando informações do SAT, um teste utilizado nos EUA para admissão em universidades. Para ter mais contexto, queremos entender quais distritos tiveram as melhores e piores notas para enviar pesquisadores para entenderem os motivos pelos quais estas notas foram boas/ruins.

O banco de dados possuí 411 entradas com 15 variáveis:

| Variável                         | Descrição
| -------------------------------- | -------------------------------------------
| dbn                              | Código de identificação da escola
| school_name                      | Nome da Escola
| num_of_sat_test_takers           | Número de testes realizados 
| critical_reading_mean            | Nota média em Leitura critica
| math_mean                        | Nota média em matemática
| writing_mean                     | Nota média em escrita
| location_name                    | Localização
| location_code                    | Código de localização
| address                          | Endereço
| geographical_district_code       | Código geográfico do distrito
| postcode                         | Código postal
| latitude                         | Latitude
| longitude                        | Longitude

Vamos aprender a fazer visualizacões?

- [Download do Banco]()

Sempre é bom recaptular. Para abrir este banco de dados podemos utilizar qual pacote?

```{r}
library(<pacote>)
banco <- read_<nome>(<caminho_do_arquivo>)
```

```{r}
library(readr)
banco <- read_csv2("data/schools_sat.csv")
```

## 1. ggplot2 

Antes de irmos diretamente para as visualizações vamos habilitar alguns pacotes:

```{r}
library(dplyr)
library(ggplot2)
# install.packages("Amelia")
library(Amelia)
```

Habilitamos dois pacotes novos, o `ggplot2` e o `Amelia`. O primeiro deles é o principal pacote para visualizações no R, possibilitando criar gráficos exatamente da forma que você quiser, sobretudo, porque ele funciona em um esquema de layers.

O segundo pacote é feito para visualizarmos valores ausentes entre variáveis, também chamado de `NA`. Apesar dele não fazer parte do `ggplot2`, é uma otíma alternativa identificarmos valores ausentes.

Mas antes vamos tratar de entender a nossa base de dados e fazer algumas manipulações nela.

A primeira coisa que iremos fazer é aplicar a função `glimpse()` do `dplyr`. Elas nos possibilita ver as nossas variáveis sem precisar abrir o banco inteiro.

```{r}
glimpse(banco)
```

Pode-se notar que todas as variáveis parecem ok! Será mesmo?

<br/>

Se você notou temos uma variável que não deveria estar aí, a X15. Além disso, vamos investigar se nosso dado possui valores ausentes? 

### Exercício

1. Remova a variável X15.

```{r}
banco <- banco %>% 
  select(-X15)
```

Vamos verificar os valores ausentes do nosso banco?

```{r}
Amelia::missmap(banco)
```

AHA! Temos valores ausentes em três variáveis, sendo elas, `math_mean`, `writing_mean` e `num_sat_test_takers`. Vamos então remover estas entradas!

2. Filtre apenas por valores que não possuem NA

```{r}
banco <- banco %>% filter(is.na(math_mean) == FALSE, is.na(writing_mean) == FALSE, is.na(num_of_sat_test_takers) == FALSE)

Amelia::missmap(banco)
```
    
3. Calcule a média por escola (media_escola) a partir das notas de matemática, escrita e leitura critíca. E partir disso, classifique se a media_escola é MAIOR ou MENOR que a media_global (transforme o resultado em fator)

```{r}
media_global <- mean(c(banco$math_mean, banco$writing_mean, banco$critical_reading_mean))

banco <- banco %>% 
  group_by(dbn) %>% 
  mutate(media_escola = mean(c(math_mean, writing_mean, critical_reading_mean)),
         categorizacao_media = case_when(media_escola >= media_global ~ "MAIOR",
                                         media_escola < media_global ~ "MENOR"),
         categorizacao_media = factor(categorizacao_media, levels = c("MAIOR", "MENOR"))) %>% 
  ungroup()
```

4. Por fim, temos 32 distritos na nossa base de dados, vamos agregar estes dados em quatro distritos agregados. Isto é, do distrito um até o oito, teremos o distrito 1 e assim por diante. (Transforme o resultado em fator)

```{r}
banco <- banco %>% 
  mutate(macro_distrito = case_when(geographical_district_code %in% c(1:8) ~ "distrito_1",
                                    geographical_district_code %in% c(9:16) ~ "distrito_2",
                                    geographical_district_code %in% c(17:24) ~ "distrito_3",
                                    geographical_district_code %in% c(25:32) ~ "distrito_4"),
         macro_distrito = factor(macro_distrito, levels = c("distrito_1", "distrito_2", "distrito_3", "distrito_4")))
```

Agora que alteramos e criamos algumas variáveis vamos conhecer o `ggplot2`.

## ggplot2

O ggplot2 é um pacote baseado no que se chamou Grammar of Graphics (por isso gg antes do plot2), que nada mais é do que uma estrutura (framework) para realização de gráficos, que nós também chamamos de "plot". Além disso, o Grammar of Graphics tem o seguinte principio:

!!! question \" Layers \"

    Gráficos são construídos com diferentes **layers**

Mas o que são **layers**? Layers são elementos (ou componentes) gramáticais utilizados para fazer um plot. Estes componentes são importantes para determinar a representação dos dados. Como o Hadley Wickham apontou em um artigo chamado "A layered grammar of graphics" (2010), a associação destes layers com uma certa grámatica auxilia o usuário em atualizar e contruir gráficos com uma facilidade maior.

Os elementos gramáticais que temos no `ggplot2` são:

a. Data - O dado que será plotado, mapeando as variáveis de interesse.

b. Aesthetics - A escala em que o dado será plotado, sinalizando os eixos x e y, cor, tamanho, preenchimento e etc.

c. Geom - Estrutura que será utilizada nos seus dados, como por exemplo, gráfico de dispersão, linha, boxplot e etc.

d. Facets - plotar multiplos grupos

e. Stats - Transformações estatísticas

f. Coordinates System - O espaço no qual o dado sera plotado, como por exemplo, espaço cartesiano, polar e entre outros.

g. Theme - Controle e modificação de aparência de tudo que não diz respeito ao dado utilizado.

h. Scales - Para cada Aesthetics, descreve como a característica visual é convertida em valores, como por exemplo, escala por tamanho, cor e etc.

É muito importante destacar que __as camadas (layers) podem aparecer em qualquer sequencia ao fazermos um gráfico e que a única camada necessária para começar um gráfico é a partir da função ggplot()__.

![](https://raw.githubusercontent.com/p4hUSP/workshops_2018.2/master/imgs/w3_03.png)
<center>
Os layers do ggplot2 (Fonte: DataCamp)
</center>

## Como fazer um gráfico no `ggplot2`

Vamos fazer um exercício de imaginação? Como nós faríamos um gráfico sem o R? Que tal um papel? Qual o passo a passo que poderíamos fazer?

<br/>

No R é semelhante. Primeiro precisamos de um papel:

```{r}
ggplot()
```

Depois, nós precisamos decidir que dados iremos utilizar e quam vai ser o eixo x e o eixo y.

```{r}
ggplot(data = banco, mapping = aes(x = num_of_sat_test_takers , y = media_escola))
```
 
Em seguida, escolhemos qual é melhor forma /estrutura para visualizar os dados.
 
```{r}
ggplot(data = banco, mapping = aes(x = num_of_sat_test_takers , y = media_escola)) + 
  geom_point()
```
 
!!! question \" Qual é a diferença do + para o %>%  \"

    Como vimos o pipe serve para deixarmos a linguagem mais linear, servindo como um conector entre as funções, porém isso não funciona com o `ggplot2`. O motivo pode ser pensado até de forma mais intuitiva: No ggplot2 estamos adicionando camadas com o sinal de mais enquanto com o `%>%` estamos dando uma sequência de ações, isto é, funções.
    
Simples, não? Apesar disso, precisamos entender alguns conceitos que vimos ao montar este gráfico, como por exemplo, colocamos os eixos x e y dentro de uma função chamada `aes()`. Ela é uma função responsável pela propriedade visual dos objetos no gráfico, em outras palavras, ela faz o "mapeamento" das variáveis do nosso banco de dados para que eles possam fazer parte dos elementos visuais do gráfico.

```{r}
ggplot(data = banco, mapping = aes(x = num_of_sat_test_takers , y = media_escola, color = macro_distrito)) + 
  geom_point()
```

Perceba que o `color = categoria_idade` afeta o `geom` que utilizamos de acordo com a variável de interesse, mas veremos adiante que também podemos alterar tanto um `geom` especificamente, quanto a cor do gráfico.

Vamos ver outros `geom_`?

### geom_col()

Para fazer este geom, eu vou manipular a base de dados para contar quantas escolas estão em cada macro distrito. Além disso, vou chamar essa nova tabela de `tab1`

```{r}
# chame esta tabela de banco para que possamos fazer outras manipulações
tab1 <- banco %>% 
  group_by(categorizacao_media) %>% 
  summarise(n = n())
tab1
```

Vamos para o geom_col()

```{r}
ggplot(data = tab1, mapping = aes(x = categorizacao_media, y = n)) + geom_col()
```

Vamos brincar um pouco com os argumentos estéticos que o ggplot2 permite?

```{r}
ggplot(data = tab1, mapping = aes(x = categorizacao_media, y = n)) + geom_col(fill = "red", width = 0.5)
```

#### Exercício

1. Aplique os parâmetros para mudar a cor (color), o tamanho (size) e o formato (shape) dos pontos do gráfico abaixo:

```{r}
ggplot(data = banco, mapping = aes(x = math_mean, y = writing_mean)) + geom_point()
```

### geom_histogram()

Se quisermos ver a distribuição de uma variável quantitativa, podemos utilizar o `geom_histogram()`! Qual será a distribuição da variável critical_reading_mean?

```{r}
ggplot(banco, aes(x = critical_reading_mean)) + geom_histogram(bins = 20)
```

Lembre-se que também podemos colocar outros atribuitos estéticos!

```{r}
ggplot(banco, aes(x = critical_reading_mean)) + geom_histogram(bins = 20, color = "blue", fill = "green")
```

### geom_boxplot() e geom_violin()

Se nós tivermos uma variável quantitativa e qualitativa, podemos utilizar o `geom_boxplot` e o `geom_violin`! Qual a distribuição da média de nota por macro distrito?

```{r}
ggplot(banco, aes(x = macro_distrito, y = media_escola)) + geom_boxplot(fill = "#444054", color = "#cc3f0c")
```

```{r}
ggplot(banco, aes(x = categorizacao_media, y = num_of_sat_test_takers)) + geom_violin(fill = "#8c1c13", alpha = 1/2)
```

### geom_line()

Para esses exemplo vamos criar a tabela abaixo primeiro:

```{r}
tab2 <- banco %>% 
  group_by(geographical_district_code) %>% 
  summarise(media_test_takers = mean(num_of_sat_test_takers))
```

Apesar de mais utilizado para séries temporais, podemos utilizar um gráfico de linhas para pensar na diferença presente nos micro distritos quanto a média de alunos fazendo o teste

```{r}
ggplot(data = tab2, mapping = aes(x = geographical_district_code, y = media_test_takers)) + geom_line(group = 1)
```

#### Exercício

1. Incluia um geom_point() no gráfico acima e altere sua cor de acordo com cada categorização de macro distritos.

E se quisermos mudar a cor da categorização para algo que gostamos mais? Para fazer isso vamos incluir mais uma camada no nosso gráfico, a camada de scale.

!!! question \" Combinando cores \"

    Se você tem dúvida de qual cor pode combinar melhor com outra, tem um [site](https://coolors.co/app) bem bacana que pode te ajudar nisso.

```{r}
tab3 <- banco %>% 
  group_by(macro_distrito) %>% 
  summarise(media_test_takers = mean(num_of_sat_test_takers))

ggplot(data = tab3, mapping = aes(x = macro_distrito, y = media_test_takers)) + geom_line(group = 1) + geom_point(aes(color = macro_distrito), size = 10) + scale_color_manual(values = c("#ff1053", "#6c6ea0", "#66c7f4", "#3299a8"))
```

Neste caso utilizamos o `scale_color_manual` pois queriamos preencher as cores de acordo com o que colocamos no paramêtro `color`. Se tivessemos escolhido o `fill` teriamos que utilizar `scale_fill_manual`.

```{r}
ggplot(banco, aes(x = categorizacao_media, y = num_of_sat_test_takers, fill = categorizacao_media)) + geom_boxplot(color = "#cc3f0c") + scale_fill_manual(values = c("#ff1053","#66c7f4"))
```

O `ggplot2` também possibilita a utilização de outros sistemas de coordenadas, como por exemplo:

- `coord_flip`

```{r}
ggplot(data = tab1, mapping = aes(x = categorizacao_media, y = n, fill = categorizacao_media)) + geom_col() + scale_fill_manual(values = c("#ff1053", "#6c6ea0")) + coord_flip()
```

- `coord_polar`

```{r}
tab3 <- banco %>% 
  group_by(macro_distrito) %>% 
  summarise(n = n()) %>% 
  mutate(p = n/sum(n))
ggplot(data = tab3, mapping = aes(x = factor(1), y = p, fill = macro_distrito)) + geom_col() + scale_fill_manual(values = c("#ff1053", "#6c6ea0", "#10f7ff", "#ff8810")) + coord_polar(theta = 'y')
```

Dica: Tome cuidado com o `coord_polar`! Ás vezes, para não dizer sempre, eles podem dificultar a visualização dos dados, sobretudo, aqueles com muitas categorias.

Vamos dar um título para nosso gráfico?

```{r}
ggplot(data = tab3, mapping = aes(x = factor(1), y = p, fill = macro_distrito)) + geom_col() + scale_fill_manual(values = c("#ff1053", "#6c6ea0", "#10f7ff", "#ff8810")) + coord_polar(theta = 'y') +
  labs(title = "Distribuição de Macro Distritos",
       x = "EIXO X", 
       y = "EIXO Y",
       caption = "SAT DATA") +
  theme_bw()
```