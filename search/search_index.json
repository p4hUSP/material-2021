{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Material Esse \u00e9 um teste!!! Quem somos? A P4H \u00e9 um grupo formado por alunos de ci\u00eancias sociais com o objetivo de aproximar alunos e profissionais da \u00e1rea de tecnologia, programa\u00e7\u00e3o e an\u00e1lise de dados. Como estudar? Programa\u00e7\u00e3o n\u00e3o se aprende apenas lendo livros e assistindo aulas. \u00c9 fundamental que voc\u00ea dedique pelo menos 1 hora do seu dia para estudar. Al\u00e9m disso, recomendamos que voc\u00ea evite apenas copiar e colar o c\u00f3digo do site para o seu computador. Escrever as fun\u00e7\u00f5es \u00e9 \u00f3timo para memoriz\u00e1-las e entender os par\u00e2metros que as fazem funcionar. O que \u00e9 uma linguagem de programa\u00e7\u00e3o e por que utilizamos uma para an\u00e1lise de dados? Uma das maiores diferen\u00e7as n\u00e3o diz respeito ao lado t\u00e9cnico. Analisar dados em Python ou em R \u00e9 gr\u00e1tis! Isso mesmo, voc\u00ea n\u00e3o precisa gastar um centavo para ter acesso a bibliotecas de an\u00e1lise de dados desenvolvidas pelo Google, Amazon, Projeto Apache, entre outras tantas. Al\u00e9m disso, ao contr\u00e1rio do Excel, do Stata e do SPSS, o R lhe d\u00e1 liberdade para resolver problemas mediante algor\u00edtmos . Ou seja, se voc\u00ea \u00e9 capaz de descrever um passo-a-passo, uma receita, de como obter um resultado a partir de determinadas entradas, podemos escrever um programa e deixar que o computador fa\u00e7a o resto.","title":"Material"},{"location":"#material","text":"Esse \u00e9 um teste!!!","title":"Material"},{"location":"#quem-somos","text":"A P4H \u00e9 um grupo formado por alunos de ci\u00eancias sociais com o objetivo de aproximar alunos e profissionais da \u00e1rea de tecnologia, programa\u00e7\u00e3o e an\u00e1lise de dados.","title":"Quem somos?"},{"location":"#como-estudar","text":"Programa\u00e7\u00e3o n\u00e3o se aprende apenas lendo livros e assistindo aulas. \u00c9 fundamental que voc\u00ea dedique pelo menos 1 hora do seu dia para estudar. Al\u00e9m disso, recomendamos que voc\u00ea evite apenas copiar e colar o c\u00f3digo do site para o seu computador. Escrever as fun\u00e7\u00f5es \u00e9 \u00f3timo para memoriz\u00e1-las e entender os par\u00e2metros que as fazem funcionar.","title":"Como estudar?"},{"location":"#o-que-e-uma-linguagem-de-programacao-e-por-que-utilizamos-uma-para-analise-de-dados","text":"Uma das maiores diferen\u00e7as n\u00e3o diz respeito ao lado t\u00e9cnico. Analisar dados em Python ou em R \u00e9 gr\u00e1tis! Isso mesmo, voc\u00ea n\u00e3o precisa gastar um centavo para ter acesso a bibliotecas de an\u00e1lise de dados desenvolvidas pelo Google, Amazon, Projeto Apache, entre outras tantas. Al\u00e9m disso, ao contr\u00e1rio do Excel, do Stata e do SPSS, o R lhe d\u00e1 liberdade para resolver problemas mediante algor\u00edtmos . Ou seja, se voc\u00ea \u00e9 capaz de descrever um passo-a-passo, uma receita, de como obter um resultado a partir de determinadas entradas, podemos escrever um programa e deixar que o computador fa\u00e7a o resto.","title":"O que \u00e9 uma linguagem de programa\u00e7\u00e3o e por que utilizamos uma para an\u00e1lise de dados?"},{"location":"01_introducao/","text":"Introdu\u00e7\u00e3o ao R Leituras recomendadas Leituras Recomendadas Cap\u00edtulos 1, 2 e 3 (Parte 1) . Grolemund, Garret. Hands-On Programming with R - Livro Cap\u00edtulo 5 (Parte 2) . Grolemund, Garret. Hands-On Programming with R - Livro Cap\u00edtulos 2, 3 e 4 . Aquino, Jakson. R para Cientistas Sociais - Livro 1. O que \u00e9 o R e o RStudio? 1.1. Linguagem de programa\u00e7\u00e3o R O R \u00e9 uma linguagem de programa\u00e7\u00e3o que vem crescendo bastante nos \u00faltimos anos. Apesar de inicialmente ter como p\u00fablico estat\u00edsticos, ela \u00e9 cada vez mais utilizada para an\u00e1lise de dados nas mais diferentes \u00e1reas. A flexibilidade trazido por uma in\u00famera quantidade de pacotes permite lidar n\u00e3o s\u00f3 com tabelas estilo Excel, mas tamb\u00e9m com texto, imagens, etc. Por\u00e9m, podemos nos sentir intimidados quando vemos o R pela primeira vez. Quando baixamos o R pela primeira vez nos assustamos com a sua interface. 1.2. RStudio Contudo, n\u00e3o se assuste. No geral, utilizamos o RStudio para criar os nossos scripts de R, que cont\u00eam o passo-a-passo das nossas an\u00e1lises. RStudio \u00e9 conhecido como uma IDE (Ambiente de Desenvolvimento Integrado) e facilita a gest\u00e3o de projetos escritos em R, com se\u00e7\u00f5es espec\u00edficas para cada funcionalidade. A - Console : Local na qual temos o console do R. No console, podemos executar os comandos que iremos ver logo a frente. Al\u00e9m disso, \u00e9 o local no qual os resultados de nossos comandos ir\u00e3o aparecer. B - File/Plots/Help : Nesta se\u00e7\u00e3o podemos ter acesso \u00e0s pastas que estamos utilizando durante as nossas rotinas no R, al\u00e9m de visualizar os gr\u00e1ficos gerados a partir das an\u00e1lises e verificar a documenta\u00e7\u00e3o de fun\u00e7\u00f5es e pacotes, que explicaremos em breve. C - Workspace : Os valores gerados no R, como por exemplo, vari\u00e1veis e tabelas que voc\u00ea definiu ir\u00e3o aparecer aqui, sobretudo, na aba Environment. E o hist\u00f3rico de c\u00f3digos rodados na aba History. Veremos nas pr\u00f3ximas aulas que a aba Connections \u00e9 \u00fatil caso estejamos conectados com alguma base de dados externa, como por exemplo, Access ou PostgreSQL. D - Editor : Se\u00e7\u00e3o na qual iremos passar a maior parte do nosso tempo. Nela, escrevemos os nossos scripts . scripts s\u00e3o arquivos de texto que cont\u00eam o nosso c\u00f3digo R. N\u00e3o se preocupe caso tenha achado um pouco confuso, vamos escrever algumas linhas de c\u00f3digo e voc\u00ea ir\u00e1 se familiarizar com o processo conforme tentar por voc\u00ea mesmo! 1.3. Nosso primeiro projeto Recomendamos voc\u00ea sempre come\u00e7ar um projeto criando um projeto (d\u00e3\u00e3). Isso \u00e9 essencial e nos ajuda a evitar ter v\u00e1rios scripts espalhados pelo nosso computador. Clique em File -> New Project -> New Directory -> New Project 1.4. Nosso primeiro script No canto superior esquerdo, clique em File \u2192 Open file . Repare que isso ir\u00e1 criar uma aba Untitled1 . Vamos salv\u00e1-la como Aula1.R . Para isso, pressione Ctrl + S e digite Aula1.R 1.5. Algumas regras de boa conduta N\u00e3o escreva diretamente no console. Salve o seu c\u00f3digo sempre em um script . Assim conseguimos ter acesso a todas as decis\u00f5es tomadas durante uma an\u00e1lise e permitir com que uma outra pessoa tamb\u00e9m chegue nos resultados que obtivermos. Nunca sobreponha o banco de dados. Uma vez que voc\u00ea tem um script , n\u00e3o \u00e9 preciso salvar as altera\u00e7\u00f5es j\u00e1 que voc\u00ea ser\u00e1 capaz de reproduzir os resultados no futuro. Comente o seu c\u00f3digo com # . Lembre-se que outras pessoas ir\u00e3o ler o seu c\u00f3digo e que elas n\u00e3o fazem ideia do que passava na sua cabe\u00e7a quando voc\u00ea tomou algumas decis\u00f5es. Al\u00e9m disso, o seu eu do futuro ir\u00e1 agradecer um c\u00f3digo bem documentado caso seja necess\u00e1rio revisit\u00e1-lo. 2. Nossas primeiras linhas de c\u00f3digo Uma das funcionalidades mais b\u00e1sicas do R \u00e9 realiza\u00e7\u00e3o de opera\u00e7\u00f5es matem\u00e1ticas. Se estamos digitando os comandos em um script , basta colocarmos o cursor do mouse na linha do c\u00f3digo e apertar Ctrl + Enter e o resultado sair\u00e1 no Console, assim como j\u00e1 hav\u00edamos mencionado. 3 + 1 # Soma 3 - 2 # Subtra\u00e7\u00e3o 4 * 2 # Multiplica\u00e7\u00e3o 5 / 2 # Divis\u00e3o 2.1. Objetos e Atribui\u00e7\u00f5es \"To understand computations in R, two slogans are helpful: \u2022 Everything that exists is an object. \u2022 Everything that happens is a function call.\" \u2014 John Chambers Dados s\u00e3o guardados dentro de objetos. Objetos possuem diferentes formas de estruturar os dados: Vetores Listas DataFrames Objetos podem conter diferentes tipos de dados: N\u00fameros Strings Fatores 2.2. Atribuindo valores \u00e0 vari\u00e1veis ( <- ) Quando fizemos as opera\u00e7\u00f5es matem\u00e1ticas, n\u00e3o salvamos os nossos resultados. Logo, caso quis\u00e9ssemos acessar novamente, por exemplo, o resultado de 3 + 1 , seria necess\u00e1rio digitar novamente 3 + 1 e efetuar a opera\u00e7\u00e3o. Contudo, \u00e9 poss\u00edvel salvar os resultados em vari\u00e1veis e, ao fazer refer\u00eancia a essas vari\u00e1veis, obter outro resultado. 3 + 1 a <- 3 + 1 c <- a * 2 # Qual o valor de C? b <- c(\"Ol\u00e1 mundo!\") b # Qual o valor de B? vetor <- c(1, 2, 3, 4, 5, 6) vetor 2.3. Tipos de dados Tipos de Dados no R (Fonte: https://www.wikitechy.com ) 2.3.1. Vari\u00e1veis do tipo num\u00e9rico De certa maneira, estamos muito acostumados com esse tipo de dados. Voc\u00ea consegue pensar em algum exemplo? Os minutos passados entre o momento que voc\u00ea saiu de casa e chegou nesta sala de aula. Renda mensal da sua fam\u00edlia. Quantidade de livros que voc\u00ea possui. Pras pessoas curiosas, tipos num\u00e9ricos podem ser divididos em inteiros ( integers ) e reais ( float ). Diferentemente de outras linguagens de programa\u00e7\u00e3o, voc\u00ea dificilmente ter\u00e1 que se preocupar com isso no R. 3 # numero inteiro 55.4 # numero real 2.3.2. Lidando com vari\u00e1veis do tipo string (texto) !!! note \"Vari\u00e1vel char no R\" No R, n\u00e3o h\u00e1 diferen\u00e7a entre vari\u00e1vel do tipo char e do tipo string . s\u00e3o conhecidos como vari\u00e1veis do tipo character . Outro tipo de vari\u00e1vel muito conhecida \u00e9 o texto ou string . Para declaramos um texto no R podemos utilizar aspas simples ( '' ) ou aspas duplas ( \"\" ), mas lembre-se n\u00e3o podemos intercalar as aspas, como por exemplo, 'ol\u00e1 mundo\" . Se come\u00e7ar um texto com aspas simples termine com aspas simples. \"Vargas\" 'J\u00e2nio Quadros' \"1945\" Perceba que devido ao fato de 1945 estar entre aspas, ele n\u00e3o \u00e9 mais um dado do tipo n\u00famero, mas sim texto e sim isso \u00e9 totalmente diferente de escrever apenas 1945 . 2.3.3. Lidando com vari\u00e1veis do tipo factor (vari\u00e1veis categ\u00f3ricas) Vamos supor que estamos trabalhando com dados de survey e em uma das quest\u00f5es temos a escala likert , em que as respostas v\u00e3o do \u201cDiscordo totalmente\u201d at\u00e9 o \u201cConcordo totalmente\u201d contabilizando um total de 6 categorias de resposta. Ocorre que para que o R entenda este tipo de dado como algo categ\u00f3rico, precisamos transform\u00e1-los em fatores ( factors ). Para fazer essa transforma\u00e7\u00e3o, utilizaremos uma fun\u00e7\u00e3o chamada factor() que recebe como par\u00e2metro um vetor com o que queremos transformar em categorias. factor(c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\")) Diferente de quando executamos um dado tipo texto, os dados categ\u00f3ricos apresentam os n\u00edveis das categorias ( levels ). Perceba que as nossas categorias n\u00e3o est\u00e3o de acordo com o que a escala likert pressup\u00f5e e para arrumar este problema, precisamos definir os n\u00edveis atrav\u00e9s de um outro par\u00e2metro da fun\u00e7\u00e3o factor() chamado levels = . factor(c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\"), levels = c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\")) Pode parecer um pouco confuso agora, mas iremos esclarecer estes pontos nos pr\u00f3ximos t\u00f3picos. 2.3.4. Lidando com data e tempo Muitas vezes precisamos lidar com data, como por exemplo, filtrar nossa an\u00e1lise em um intervalo de tempo. Por\u00e9m, n\u00fameros e textos n\u00e3o s\u00e3o suficientes para entender as regras impostas pelas datas, como por exemplo, \u201c01/01/2019\u201d \u00e9 mais recente que \u201c31/12/2018\u201d. Sys.Date() Parece uma vari\u00e1vel texto, n\u00e3o? Por\u00e9m se aplicarmos a fun\u00e7\u00e3o class() , que serve para verificarmos o tipo de uma vari\u00e1vel, podemos ver que se trata de uma vari\u00e1vel do tipo Date . Nem sempre teremos que nos preocupar com isso, mas caso voc\u00ea esteja querendo plotar uma s\u00e9rie temporal essa transforma\u00e7\u00e3o \u00e9 bem importante. class(Sys.Date()) !!! note \"Curiosidade\" Caso voc\u00ea tenha ficado curiosa, por baixo a vari\u00e1vel Date \u00e9 do tipo num\u00e9rico e, por conven\u00e7\u00e3o, nada mais \u00e9 do que a quantidade de segundos passados desde 1 de Janeiro de 1970. 2.3.5. Lidando com l\u00f3gicos/booleanos Valores booleanos s\u00e3o resultados de opera\u00e7\u00f5es booleanas e podem ser definidos como verdadeiros ou falsos . Por conven\u00e7\u00e3o, trabalhamos com os termos em ingl\u00eas. Portanto, TRUE ou FALSE . Por opera\u00e7\u00f5es booleanas, podemos pensar em diferentes testes que tenham necessariamente uma resposta ou verdadeira ou falsa. Por exemplo, 3 \u00e9 maior do que 1? Verdadeiro! E 3 \u00e9 menor do que 2? Falso! Vamos realizar essas duas opera\u00e7\u00f5es no R. # 3 \u00e9 maior do que 1? 3 > 1 # 3 \u00e9 maior do que 1? 3 < 2 Existem, obviamente, outras opera\u00e7\u00f5es. \u00c9 poss\u00edvel tamb\u00e9m testar a igualdade entre dois valores com == . # 2 \u00e9 igual a 2? 2 == 2 Tamb\u00e9m podemos testar se dois valores s\u00e3o diferentes. #120 \u00e9 diferente de 20? 120 != 20 Outras varia\u00e7\u00f5es utilizadas s\u00e3o o maior ou igual ( >= ) e o menor ou igual ( <= ). Al\u00e9m disso, tamb\u00e9m \u00e9 poss\u00edvel realizar essas opera\u00e7\u00f5es com textos. # \"FFLCH\" \u00e9 igual a \"ICB\"? \"FFLCH\" == \"ICB\" !!! question \"Qual texto \u00e9 maior?\" Na sua opini\u00e3o, qual \u00e9 o resultado de \"Acre\" > \"S\u00e3o Paulo\" ? Na pr\u00e1tica, podemos utilizar essas opera\u00e7\u00f5es para filtrar o nosso banco de dados. Imagine, por exemplo, que voc\u00ea possui um banco de dados das elei\u00e7\u00f5es municipais realizadas no Brasil em 2020, mas que quisesse apenas o resultado do Rio de Janeiro. Mediante uma opera\u00e7\u00e3o booleana, podemos fazer algo como cidade == \"Rio de Janeiro\" e selecionar apenas o resultado dessa cidade. 2.3.6. Valores Ausentes ou Missing O que s\u00e3o missing e por que existe um valor especial para eles? Missing representam valores desconhecidos. Imagine que, durante uma pesquisa sobre prefer\u00eancia pol\u00edtica, a pessoa entrevistada se recusa a responder a pergunta \u201cVoc\u00ea votou na \u00faltima elei\u00e7\u00e3o?\u201d. O fato dela se recusar n\u00e3o significa que ela n\u00e3o tenha votada. N\u00f3s simplesmente n\u00e3o sabemos e precisamos representar isso nos nossos dados para tratarmos esses casos eventualmente. Tipos de missing Existem dois tipos de valores missing, o NA ( not available ) e o NaN ( not a number ), ambos tem sentidos semelhantes, por\u00e9m o primeiro \u00e9 mais gen\u00e9rico para cada tipo de dado. Para sabermos se um certo dado \u00e9 missing , utilizamos a fun\u00e7\u00e3o is.na() . is.na(NA) is.na(99) Por que esse c\u00f3digo retorna NA ? NA == NA 3. Exerc\u00edcios - Parte 1 3.1. Tipos de Dados Quais os tipos de cada vari\u00e1vel apresentada abaixo? !!! warning \"\" Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 33.5 20 \"Ol\u00e1 mundo!\" factor(\"oi\", levels = c(\"oi\", \"tchau\")) TRUE FALSE 3.2. Encontre o erro Verifique se as express\u00f5es abaixo s\u00e3o v\u00e1lidas ou n\u00e3o. Caso n\u00e3o sejam, reescreva-as de maneira que sejam v\u00e1lidas. !!! warning \"\" Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 22,2 'O 'R' \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal' 4. Estruturas de dados As estruturas de dados s\u00e3o maneiras de organizar e guardar dados dentro da linguagem para que possamos trabalhar de forma mais eficiente. No nosso cotidiano utilizaremos tr\u00eas destas estruturas: vetores e dataframes . 4.1. Vetores Um vetor at\u00f4mico \u00e9 a estrutura mais b\u00e1sica no R; \u00e9 um vetor de dados homog\u00eaneo com apenas uma dimens\u00e3o. Imagine o vetor como um trem cujos valores est\u00e3o ordenados e s\u00e3o obrigatoriamente do mesmo tipo ( numeric ). Ilustra\u00e7\u00e3o de um trem Que tal um exemplo? Imagine que voc\u00ea queira organizar em um vetor a quantidade de pessoas dentro de vag\u00f5es de um trem. Nesse sentido, a quantidade de pessoas no primeira vag\u00e3o \u00e9 seguida da quantidade de pessoas no segundo e assim por diante. c(120, 29, 191, 18, 39) Quantas pessoas est\u00e3o no segundo vag\u00e3o? 29? Acertou! Perceba ent\u00e3o que para construir um vetor basta colocarmos os valores dentro de c() . 4.1.1. Indexando vetores !!! warning \"\" Se voc\u00ea tem experi\u00eancia com programa\u00e7\u00e3o, o R \u00e9 diferent\u00e3o dentro desse mundo. Todas as estruturas s\u00e3o indexadas a partir do valor 1 , ou seja, para acessar o primeiro valor de um vetor, voc\u00ea executar\u00e1 algo como vetor[1] . Podemos acessar os valores espec\u00edficos de um vetor a partir da posi\u00e7\u00e3o dele nessa estrutura. No exemplo anterior, voc\u00ea poderia ter pedido para o R lhe retornasse quem est\u00e1 na segunda posi\u00e7\u00e3o. Para isso, basta utilizar trem[2] como no exemplo a seguir. trem <- c(120, 29, 191, 18, 39) trem[2] Para indexarmos mais de um elemento podemos indexar de duas formas. Logo se quis\u00e9ssemos o n\u00famero de pessoas no terceiro e quarto vag\u00e3o: trem[c(3,4)] trem[3:4] O que acontece se voc\u00ea utilizar [3:5] ? trem[3:5] 4.2. Dataframes O dataframe \u00e9 semelhante a uma planilha de Excel ou Google Sheets. Ela \u00e9 uma representa\u00e7\u00e3o feita dentro do R para estruturas que possuem linhas e colunas. As colunas, no geral, ser\u00e3o as nossas vari\u00e1veis, as informa\u00e7\u00f5es sobre uma determinada unidade observacional (pessoas, estados, pa\u00edses, etc.), enquanto cada linha representa uma observa\u00e7\u00e3o. Por exemplo, caso fiz\u00e9ssemos um dataframe com informa\u00e7\u00f5es sobre os pa\u00edses do mundo, cada linha seria um pa\u00eds e cada coluna uma informa\u00e7\u00e3o sobre esse ele. tabela <- data.frame(ano = c(2014, 2014, 2015, 2015, 2016, 2016), pais = c('Brasil', 'China', 'Brasil', 'China', 'Brasil', 'China'), pib = c(100,130, 110, 140, 160, 170), pop = c(3, 8, 4, 9, 6, 14)) tabela Diferentemente do Excel, n\u00e3o podemos selecionar uma c\u00e9lula e alterar um dado. No R, para manipular e visualizar uma tabela precisamos utilizar fun\u00e7\u00f5es. N\u00e3o se estresse caso nunca tenho ouvido falar delas. Pense apenas que elas realizam alguma a\u00e7\u00e3o . Repare nos resultados das fun\u00e7\u00f5es a seguir: View(tabela) # mostra o banco no console head (tabela) # mostra as seis primeiras linhas do banco no console str(tabela)# mostra a estrutura da tabela names(tabela) # mostra o nome das vari\u00e1veis nrow(tabela) # n\u00ba de linhas ncol(tabela) #n\u00ba de colunas dim(tabela) # dimens\u00f5es 4.3.1. Indexando Para indexar dataframes , voc\u00ea precisa levar em conta a caracter\u00edstica bidimensional dessa estrutura de dados. Uma tabela ser\u00e1 indexada com tabela[linha, coluna] . tabela[1, 2] # Primeira linha, segunda coluna tabela[1,] # Primeira linha, todas as colunas tabela[,1] # Todas as linhas, primeira coluna tabela[1:3,] # Linhas de 1 at\u00e9 3, todas as colunas tabela[,2:4] # todas as linhas, colunas de 2 at\u00e9 4 Como dataframes possuem colunas e as colunas, nomes, podemos utilizar o nome das colunas para selecion\u00e1-las. tabela[,\"pais\"] # Todas as linhas da coluna \"pais\" tabela[2,\"pais\"] # O valor da segunda linha e da coluna \"pais\" tabela[, c(\"pais\", \"pib\")] # Todas as linhas das colunas \"pais\" e \"pib\" Por fim, tamb\u00e9m podemos indexar utilizando o operador $ seguido do nome da coluna. tabela$pib tabela$pib[1] 4.3.2. Importando dataframes (csv, Excel, etc.) Uma das maneiras mais eficientes de se importar dados para o R \u00e9 pelo uso dos seguintes pacotes: readr para a leitura de CSVs. readxl para a leitura de planilhas de Excel. haven para a leitura de arquivos. Instalando pacotes do R O R n\u00e3o possui todos os pacotes previamente. Em geral, utilizaremos o comando install.packages() para instalar pacotes no R. Execute o comando install.packages(c('readr', 'readxl', 'haven')) . Lembre-se de carregar o pacote no R com o comando library() . Por exemplo, library(readr) . Voc\u00ea sabia que o TSE (Tribunal Superior Eleitoral) libera diversos dados sobre as elei\u00e7\u00f5es no site deles? Que tal tentar baixar o banco de candidatos? Para isso, baixe os arquivos: Candidatos - CSV Candidatos - CSV2 Candidatos - TAB Candidatos - Arroba Candidatos - Excel Candidatos - Stata \u00c0s vezes, o navegador n\u00e3o ir\u00e1 fazer o download automaticamente (normalmente isso ocorre no Firefox) e lhe mostrar\u00e1 uma tela repleta de caracteres. Calma! Clique com o bot\u00e3o direito na tela e selecione a op\u00e7\u00e3o Save Page As\u2026 . Recomendamos que voc\u00ea salve os dados dentro de uma pasta chamada data ou dados para manter o projeto organizado. Para importar um CSV para o R, utilize a fun\u00e7\u00e3o read_csv() do pacote readr . Fique atento com o lugar que voc\u00ea salvou os arquivos! Neste exemplo, os arquivos est\u00e3o salvos dentro da pasta data . library(readr) banco_virgula <- read_csv('data/candidatos_sp_virgula.csv') Se tudo tiver dado certo, agora voc\u00ea ter\u00e1 um banco_virgula no seu ambiente de vari\u00e1veis. Mas nem sempre um banco de dados \u00e9 separado por v\u00edrgula e mesmo assim ele pode ter a extens\u00e3o .csv . Bancos separados por ponto e v\u00edrgula ; . banco_pontovirgula <- read_csv2('data/candidatos_sp_pontovirgula.csv') Banco separados por tabs \\t . banco_tab <- read_tsv('data/candidatos_sp_tab.csv') Banco separados por @ ou qualquer outro caractere . banco_arroba <- read_delim('data/candidatos_sp_arroba.csv', delim = '@') Banco Excel. library(readxl) banco_excel <- read_excel('data/candidatos_sp_excel.xlsx') Repare que o n\u00famero de linhas do banco Excel \u00e9 menor! Por que isso aconteceu? Banco Excel - Abas library(readxl) banco_excel_1 <- read_excel('data/candidatos_sp_excel.xlsx', sheet = 1) banco_excel_1 <- read_excel('data/candidatos_sp_excel.xlsx', sheet = 2) Banco Stata library(haven) banco_stata <- read_stata('data/candidatos_sp_stata.dta') 5. Exerc\u00edcio - Parte 2 5.1. DataFrames Crie um dataframe com o \u201cnome\u201d, \u201cidade\u201d e \u201cfilme\u201d preferido dos seus colegas de turma. Como criar um dataframe? Lembre-se que para criar um dataframe utilizamos a fun\u00e7\u00e3o data.frame() e que essa fun\u00e7\u00e3o recebe vetores como par\u00e2metros para cada coluna que desejamos criar. Por exemplo, se voc\u00ea quiser criar uma dataframe com uma lista de n\u00fameros basta executar data.frame(lista_numeros = c(1,2,3,4,5,6,7)) No R temos, bancos para fins did\u00e1ticos. Para utiliz\u00e1-los basta usar a fun\u00e7\u00e3o data. Para esse exerc\u00edcios utilizaremos o banco mtcars. Execute data(mtcars) . Repare que agora voc\u00ea pode acessar o banco mtcars da mesma maneira que fizemos anteriormente com outros dataframes. Visualize o banco. Do que se trata? Quais s\u00e3o suas vari\u00e1veis? E suas dimens\u00f5es? Selecione as 10 primeiras observa\u00e7\u00f5es 5. Fun\u00e7\u00f5es Como voc\u00ea deve ter notado mencionamos algumas vezes a palavra fun\u00e7\u00e3o durante o texto. Mas o que \u00e9 isso? Podemos pensar cada fun\u00e7\u00e3o como uma a\u00e7\u00e3o . Por exemplo, imagine voc\u00ea possa controlar a sua vida por meio de fun\u00e7\u00f5es . Se as coisas funcionam assim, provavelmente ter\u00edamos uma fun\u00e7\u00e3o levantar() , beber_aguar() e assim por diante. No R, o princ\u00edpio \u00e9 o mesmo e precisamos utilizar fun\u00e7\u00f5es para executar quaisquer comandos que precisamos que sejam operados. Por exemplo, quando voc\u00ea executou read_csv() , voc\u00ea chamou um c\u00f3digo que abre o arquivo especificado e estrutura cada linha dentro de um dataframe. Mas como uma fun\u00e7\u00e3o sabe sobre onde ela precisa operar? Como read_csv() sabia que precisava abrir aquele arquivo? Para isso, utilizamos par\u00e2metros . Par\u00e2metros alteram o comportamento das nossas fun\u00e7\u00f5es e nos permitem especificar, por exemplo, um arquivo para a read_csv() escrevendo read_csv('arquivo.csv') . Vamos ver isso na pr\u00e1tica com outra fun\u00e7\u00e3o bastante importante, a mean() . Como aprender a utilizar fun\u00e7\u00f5es? Obviamente, voc\u00ea pode utilizar o Google, mas muitas vezes n\u00e3o \u00e9 necess\u00e1rio sair do RStudio. Se voc\u00ea quiser, utilize o comando ?mean e tente ler a documenta\u00e7\u00e3o e os exemplos. Pacotes instalados pelo CRAN necessariamente s\u00e3o acompanhados por uma documenta\u00e7\u00e3o que explica o que as suas fun\u00e7\u00f5es fazem. Vamos tentar rodar um exemplo? x <- c(1,2,3) xm <- mean(x) xm A fun\u00e7\u00e3o mean() calcula a m\u00e9dia de qualquer vetor num\u00e9rico para a gente e podemos utilizar para ter uma no\u00e7\u00e3o dos nossos dados durante uma an\u00e1lise. 5.1. Pacotes Segundo a defini\u00e7\u00e3o do livro R Packages, escrito por Hadley Wickham, um pacote \u00e9 uma unidade fundamental de compartilhamento de c\u00f3digos, dados, documenta\u00e7\u00e3o e testes. Em outras palavras, os pacotes s\u00e3o cole\u00e7\u00f5es de c\u00f3digos (fun\u00e7\u00f5es) e dados desenvolvidos pela comunidade. Estes pacotes ficam localizados no que chamamos de reposit\u00f3rio. O principal reposit\u00f3rio recebe o nome de C omprehensive R A rchive N etwork, o tamb\u00e9m chamado, CRAN. Mas existem outros tamb\u00e9m, como o Github, no qual a forma de obter os pacotes muda. Para instalar um pacote, utilize o comando install.packages() em que o argumento principal \u00e9 o nome do pacote que queremos instalar. Uma peculiaridade desta fun\u00e7\u00e3o \u00e9 que por padr\u00e3o ela instala os pacotes que est\u00e3o no CRAN, como por exemplo, vamos instalar um pacote chamado \u201cdplyr\u201d install.packages(\"dplyr\") Ap\u00f3s instalarmos o pacote, devemos habilit\u00e1-lo com uma fun\u00e7\u00e3o chamada library() library(dplyr) Caso o pacote n\u00e3o esteja no CRAN, mas sim no Github, devemos instalar o pacote com o auxilio de uma fun\u00e7\u00e3o chamada install_github() do pacote devtools . install.packages(\"devtools\") library(devtools) Pacotes no GitHub Caso o seu pacote n\u00e3o esteja liberado no CRAN ou caso deseje ter acesso \u00e0 vers\u00e3o de desenvolvimento, voc\u00ea ir\u00e1 precisar utilizar a fun\u00e7\u00e3o install_github() do pacote devtools que recebe como par\u00e2metro <dono-do-pacote>/<nome-do-pacote> . Por exemplo, install_github(\"abjur/abjutils\") . N\u00e3o se esque\u00e7a de habilitar o devtools com a fun\u00e7\u00e3o library(devtools) . 6. Controladores de Fluxo \u00c9 muito comum estabelecermos uma condi\u00e7\u00e3o para tomar uma decis\u00e3o, como por exemplo, \u2018Porcentagem de votos maior que 50% pode significar vit\u00f3ria, caso contr\u00e1rio, derrota\u2019. Para que possamos fazer isso, utilizaremos o if/else e o for ! 6.1. if/else A estrutura do if/else \u00e9 a seguinte: if(<condicao>){ <comando1> <comando2> <etc> }else{ <comando3> <comando4> <etc> } Podemos interpret\u00e1-la da seguinte maneira: Se a condi\u00e7\u00e3o for verdadeira, execute os comandos 1 e 2, caso contr\u00e1rio, execute os comandos 3 e 4. 6.2. for for (i in x){ <comando1> <comando2> } N\u00f3s lemos o for acima da seguinte maneira: Para cada valor \u201ci\u201d presente na sequ\u00eancia \u201cx\u201d, realize tais comandos. Ou seja, para cada linha da nossa tabela, some um ao percentual de votos recebidos. Vamos criar o seguinte dataframe : ano : ano da observa\u00e7\u00e3o. pais : pa\u00eds da observa\u00e7\u00e3o. pip : Produto Interno Bruto do pa\u00eds. pop : Popula\u00e7\u00e3o do pa\u00eds. tabela <- data.frame(ano = c(2014, 2014, 2015, 2015, 2016, 2016), pais = c('Brasil', 'China', 'Brasil', 'China', 'Brasil', 'China'), pib = c(100,130, 110, 140, 160, 170), pop = c(3, 8, 4, 9, 6, 14)) Nosso objetivo: Criar uma terceira coluna com o PIB per capta com um for for(i in 1:nrow(tabela)){ print(tabela$pib[i]) } Vamos entender algumas coisas aqui, nrow(tabela) \u00e9 uma fun\u00e7\u00e3o que retorna o n\u00famero de linhas de uma tabela, ou seja, seu resultado \u00e9 um n\u00famero. Quando temos 1:nrow(tabela) , estamos criando um vetor com uma sequ\u00eancia de 1 at\u00e9 o n\u00famero de linhas da nossa tabela, no caso, 6. Isso significa que nosso for vai percorrer as treze linhas da tabela. Uma vez que o i assumir\u00e1 os valores de 1 at\u00e9 6, podemos indexar o vetor tabela$pip[i] com o [i] para obter o n\u00famero do PIB correspondente a linha i . Dessa maneira podemos dividir tabela$pip[i] pela tabela$pop[i] e obter a _renda per capta. Vamos agora voltar ao nosso objetivo principal: tabela$pib_capta <- NA # Criando uma coluna vazia for(i in 1:nrow(tabela)){ tabela$pib_capta[i] <- tabela$pib[i] / tabela$pop[i] } print(tabela) Por fim, n\u00f3s podemos misturar o for com o if para obter um comportamento customiz\u00e1vel dentro do nosso loop . Por exemplo, vamos criar uma classifica\u00e7\u00e3o de PIB per capta entre alto e baixo. Para isso, iremos utilizar o 20 como o discriminador entre essas duas classes. Nesse sentido, se pib_capta for maior do que 20 devemos classificar tabela$pip_capta_class <- NA # Criando uma coluna vazia for(i in 1:nrow(tabela)){ if(tabela$pib_capta[i] > 20){ tabela$pip_capta_class[i] <- 'Alto' } else { tabela$pip_capta_class[i] <- 'Baixo' } } print(tabela) PARAB\u00c9NS!!! :tada: :tada: :tada: Enfim, ap\u00f3s esse breve resumos de conceitos b\u00e1sicos de programa\u00e7\u00e3o voc\u00ea ser\u00e1 capaz de interagir com pacotes com uma vasta variedade de pacotes, al\u00e9m de conseguir desenvolver as pr\u00f3prias solu\u00e7\u00f5es quando for necess\u00e1rio. 7. Exerc\u00edcios Exerc\u00edcio 1 - Tipos de dados Execute os c\u00f3digos abaixo e verifique se s\u00e3o dados v\u00e1lidos em R. Caso verdadeiro, informe o tipo de dado: Obs: Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 33,5 \"Ol\u00e1 mundo\" \"O 'R' \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal' 400e + 10 factor(\"oi\", levels = c(\"oi\", \"tchau\")) true False Exerc\u00edcio 2 - Manipulando vari\u00e1veis Altere o valor de v_numero para 42 v_numero <- 42.5 Altere o valor de v_caractere para \u201cuniverso\u201d. v_caractere <- \"algum texto\"` Altere o valor de v_logical para FALSE `v_logical <- TRUE` Exerc\u00edcio 3 - Estruturas de Dados Crie dois vetores: O primeiro ( nome ) deve conter o nome de pelo menos 5 colegas que est\u00e3o sentandos ao seu redor. O segundo ( altura ) deve conter a altura desses colegas. vetor_nome <- c() vetor_altura <- c() Acesse o primeiro nome do vetor_nome . Lembre-se que voc\u00ea precisa dos [] . Acesse os primeiros tr\u00eas valores de altura no vetor_altura . Fa\u00e7a isso apenas utilizando [] e : Fa\u00e7a isso apenas utilizando [] e c() Crie um dataframe a partir de vetor_nome e vetor_altura . tabela_colegas <- data.frame(nome = <completar>, altura = <completar>) Usando a indexa\u00e7\u00e3o , obtenha: O vetor nome dentro do dataframe tabelas_colegas O vetor altura dentro do dataframe tabelas_colegas Obtenha a primeira observa\u00e7\u00e3o da sua tabela (primeira linha) Utilizando fun\u00e7\u00f5es obtenha: A m\u00e9dia de altura dos seus colegas Uma tabela ( table() ) dos nomes dos seus colegas O desvio padr\u00e3o da altura ( sd() ) Exerc\u00edcio 4 - Controladores de Fluxo Imprima todas as alturas de tabelas_colegas com for e print() . Crie uma classifica\u00e7\u00e3o para a altura dos seus colegas com for e if . N\u00e3o se preocupe com o valor utilizado. Contudo, case deseje, voc\u00ea pode dividi-los pela mediana ou pela m\u00e9dia . Exerc\u00edcio 5 - Importa\u00e7\u00e3o de Dados Escolha um dos bancos abaixo ou qualquer outro de seu interesse. Baixe o banco, utilize as fun\u00e7\u00f5es para explorar as vari\u00e1veis, retire algum resumo de uma vari\u00e1vel (m\u00e9dia, contagem, etc.). Relembrando as fun\u00e7\u00f5es Voc\u00ea pode utilizar View() , head() , str() , names() , entre outras para ter uma ideia geral do banco de dados. Para extrair estat\u00edsticas, voc\u00ea pode utilizar mean() , sd() , median() , etc. Lembre-se que o Google \u00e9 o seu melhor amigo! Pesquisa outros comandos que sejam do seu interesse! Banco Link Banco Elei\u00e7\u00f5es Download Pre\u00e7o M\u00e9dio de Combust\u00edveis no Brasil Download Banco de Pokemon Download Vagas de Emprego em Nova Iorque Download Exerc\u00edcio 6 - Desafio Com o banco de dados do exerc\u00edcio anterior tente levantar algumas hip\u00f3teses sobre as rela\u00e7\u00f5es de vari\u00e1veis. Por exemplo, \u201ceu acho que X causa Y\u201d. Anote todas essas hip\u00f3teses. Uma vez feito isso, tente: Criar um gr\u00e1fico que ressalte a rela\u00e7\u00e3o entre essas vari\u00e1veis. Procure rodar um teste estat\u00edstico que ponha \u00e0 prova a sua hip\u00f3tese (Teste t, ANOVA, regress\u00e3o linear, regress\u00e3o log\u00edstica, etc.). Por onde come\u00e7ar? Existe um pacote de visualiza\u00e7\u00e3o de dados muito famoso para o R chamado ggplot2 . Quanto ao teste estat\u00edstico, o R possu\u00ed todos os testes citados implementados, ou seja, voc\u00ea n\u00e3o precisa baixar um pacote para aplic\u00e1-los. Tente procurar na internet . Existem refer\u00eancias tanto em portugu\u00eas quanto em ingl\u00eas .","title":"Introdu\u00e7\u00e3o"},{"location":"01_introducao/#introducao-ao-r","text":"","title":"Introdu\u00e7\u00e3o ao R"},{"location":"01_introducao/#leituras-recomendadas","text":"Leituras Recomendadas Cap\u00edtulos 1, 2 e 3 (Parte 1) . Grolemund, Garret. Hands-On Programming with R - Livro Cap\u00edtulo 5 (Parte 2) . Grolemund, Garret. Hands-On Programming with R - Livro Cap\u00edtulos 2, 3 e 4 . Aquino, Jakson. R para Cientistas Sociais - Livro","title":"Leituras recomendadas"},{"location":"01_introducao/#1-o-que-e-o-r-e-o-rstudio","text":"","title":"1. O que \u00e9 o R e o RStudio?"},{"location":"01_introducao/#11-linguagem-de-programacao-r","text":"O R \u00e9 uma linguagem de programa\u00e7\u00e3o que vem crescendo bastante nos \u00faltimos anos. Apesar de inicialmente ter como p\u00fablico estat\u00edsticos, ela \u00e9 cada vez mais utilizada para an\u00e1lise de dados nas mais diferentes \u00e1reas. A flexibilidade trazido por uma in\u00famera quantidade de pacotes permite lidar n\u00e3o s\u00f3 com tabelas estilo Excel, mas tamb\u00e9m com texto, imagens, etc. Por\u00e9m, podemos nos sentir intimidados quando vemos o R pela primeira vez. Quando baixamos o R pela primeira vez nos assustamos com a sua interface.","title":"1.1. Linguagem de programa\u00e7\u00e3o R"},{"location":"01_introducao/#12-rstudio","text":"Contudo, n\u00e3o se assuste. No geral, utilizamos o RStudio para criar os nossos scripts de R, que cont\u00eam o passo-a-passo das nossas an\u00e1lises. RStudio \u00e9 conhecido como uma IDE (Ambiente de Desenvolvimento Integrado) e facilita a gest\u00e3o de projetos escritos em R, com se\u00e7\u00f5es espec\u00edficas para cada funcionalidade. A - Console : Local na qual temos o console do R. No console, podemos executar os comandos que iremos ver logo a frente. Al\u00e9m disso, \u00e9 o local no qual os resultados de nossos comandos ir\u00e3o aparecer. B - File/Plots/Help : Nesta se\u00e7\u00e3o podemos ter acesso \u00e0s pastas que estamos utilizando durante as nossas rotinas no R, al\u00e9m de visualizar os gr\u00e1ficos gerados a partir das an\u00e1lises e verificar a documenta\u00e7\u00e3o de fun\u00e7\u00f5es e pacotes, que explicaremos em breve. C - Workspace : Os valores gerados no R, como por exemplo, vari\u00e1veis e tabelas que voc\u00ea definiu ir\u00e3o aparecer aqui, sobretudo, na aba Environment. E o hist\u00f3rico de c\u00f3digos rodados na aba History. Veremos nas pr\u00f3ximas aulas que a aba Connections \u00e9 \u00fatil caso estejamos conectados com alguma base de dados externa, como por exemplo, Access ou PostgreSQL. D - Editor : Se\u00e7\u00e3o na qual iremos passar a maior parte do nosso tempo. Nela, escrevemos os nossos scripts . scripts s\u00e3o arquivos de texto que cont\u00eam o nosso c\u00f3digo R. N\u00e3o se preocupe caso tenha achado um pouco confuso, vamos escrever algumas linhas de c\u00f3digo e voc\u00ea ir\u00e1 se familiarizar com o processo conforme tentar por voc\u00ea mesmo!","title":"1.2. RStudio"},{"location":"01_introducao/#13-nosso-primeiro-projeto","text":"Recomendamos voc\u00ea sempre come\u00e7ar um projeto criando um projeto (d\u00e3\u00e3). Isso \u00e9 essencial e nos ajuda a evitar ter v\u00e1rios scripts espalhados pelo nosso computador. Clique em File -> New Project -> New Directory -> New Project","title":"1.3. Nosso primeiro projeto"},{"location":"01_introducao/#14-nosso-primeiro-script","text":"No canto superior esquerdo, clique em File \u2192 Open file . Repare que isso ir\u00e1 criar uma aba Untitled1 . Vamos salv\u00e1-la como Aula1.R . Para isso, pressione Ctrl + S e digite Aula1.R","title":"1.4. Nosso primeiro script"},{"location":"01_introducao/#15-algumas-regras-de-boa-conduta","text":"N\u00e3o escreva diretamente no console. Salve o seu c\u00f3digo sempre em um script . Assim conseguimos ter acesso a todas as decis\u00f5es tomadas durante uma an\u00e1lise e permitir com que uma outra pessoa tamb\u00e9m chegue nos resultados que obtivermos. Nunca sobreponha o banco de dados. Uma vez que voc\u00ea tem um script , n\u00e3o \u00e9 preciso salvar as altera\u00e7\u00f5es j\u00e1 que voc\u00ea ser\u00e1 capaz de reproduzir os resultados no futuro. Comente o seu c\u00f3digo com # . Lembre-se que outras pessoas ir\u00e3o ler o seu c\u00f3digo e que elas n\u00e3o fazem ideia do que passava na sua cabe\u00e7a quando voc\u00ea tomou algumas decis\u00f5es. Al\u00e9m disso, o seu eu do futuro ir\u00e1 agradecer um c\u00f3digo bem documentado caso seja necess\u00e1rio revisit\u00e1-lo.","title":"1.5. Algumas regras de boa conduta"},{"location":"01_introducao/#2-nossas-primeiras-linhas-de-codigo","text":"Uma das funcionalidades mais b\u00e1sicas do R \u00e9 realiza\u00e7\u00e3o de opera\u00e7\u00f5es matem\u00e1ticas. Se estamos digitando os comandos em um script , basta colocarmos o cursor do mouse na linha do c\u00f3digo e apertar Ctrl + Enter e o resultado sair\u00e1 no Console, assim como j\u00e1 hav\u00edamos mencionado. 3 + 1 # Soma 3 - 2 # Subtra\u00e7\u00e3o 4 * 2 # Multiplica\u00e7\u00e3o 5 / 2 # Divis\u00e3o","title":"2. Nossas primeiras linhas de c\u00f3digo"},{"location":"01_introducao/#21-objetos-e-atribuicoes","text":"\"To understand computations in R, two slogans are helpful: \u2022 Everything that exists is an object. \u2022 Everything that happens is a function call.\" \u2014 John Chambers Dados s\u00e3o guardados dentro de objetos. Objetos possuem diferentes formas de estruturar os dados: Vetores Listas DataFrames Objetos podem conter diferentes tipos de dados: N\u00fameros Strings Fatores","title":"2.1. Objetos e Atribui\u00e7\u00f5es"},{"location":"01_introducao/#22-atribuindo-valores-a-variaveis-","text":"Quando fizemos as opera\u00e7\u00f5es matem\u00e1ticas, n\u00e3o salvamos os nossos resultados. Logo, caso quis\u00e9ssemos acessar novamente, por exemplo, o resultado de 3 + 1 , seria necess\u00e1rio digitar novamente 3 + 1 e efetuar a opera\u00e7\u00e3o. Contudo, \u00e9 poss\u00edvel salvar os resultados em vari\u00e1veis e, ao fazer refer\u00eancia a essas vari\u00e1veis, obter outro resultado. 3 + 1 a <- 3 + 1 c <- a * 2 # Qual o valor de C? b <- c(\"Ol\u00e1 mundo!\") b # Qual o valor de B? vetor <- c(1, 2, 3, 4, 5, 6) vetor","title":"2.2. Atribuindo valores \u00e0 vari\u00e1veis (&lt;-)"},{"location":"01_introducao/#23-tipos-de-dados","text":"Tipos de Dados no R (Fonte: https://www.wikitechy.com )","title":"2.3. Tipos de dados"},{"location":"01_introducao/#231-variaveis-do-tipo-numerico","text":"De certa maneira, estamos muito acostumados com esse tipo de dados. Voc\u00ea consegue pensar em algum exemplo? Os minutos passados entre o momento que voc\u00ea saiu de casa e chegou nesta sala de aula. Renda mensal da sua fam\u00edlia. Quantidade de livros que voc\u00ea possui. Pras pessoas curiosas, tipos num\u00e9ricos podem ser divididos em inteiros ( integers ) e reais ( float ). Diferentemente de outras linguagens de programa\u00e7\u00e3o, voc\u00ea dificilmente ter\u00e1 que se preocupar com isso no R. 3 # numero inteiro 55.4 # numero real","title":"2.3.1. Vari\u00e1veis do tipo num\u00e9rico"},{"location":"01_introducao/#232-lidando-com-variaveis-do-tipo-string-texto","text":"!!! note \"Vari\u00e1vel char no R\" No R, n\u00e3o h\u00e1 diferen\u00e7a entre vari\u00e1vel do tipo char e do tipo string . s\u00e3o conhecidos como vari\u00e1veis do tipo character . Outro tipo de vari\u00e1vel muito conhecida \u00e9 o texto ou string . Para declaramos um texto no R podemos utilizar aspas simples ( '' ) ou aspas duplas ( \"\" ), mas lembre-se n\u00e3o podemos intercalar as aspas, como por exemplo, 'ol\u00e1 mundo\" . Se come\u00e7ar um texto com aspas simples termine com aspas simples. \"Vargas\" 'J\u00e2nio Quadros' \"1945\" Perceba que devido ao fato de 1945 estar entre aspas, ele n\u00e3o \u00e9 mais um dado do tipo n\u00famero, mas sim texto e sim isso \u00e9 totalmente diferente de escrever apenas 1945 .","title":"2.3.2. Lidando com vari\u00e1veis do tipo string (texto)"},{"location":"01_introducao/#233-lidando-com-variaveis-do-tipo-factor-variaveis-categoricas","text":"Vamos supor que estamos trabalhando com dados de survey e em uma das quest\u00f5es temos a escala likert , em que as respostas v\u00e3o do \u201cDiscordo totalmente\u201d at\u00e9 o \u201cConcordo totalmente\u201d contabilizando um total de 6 categorias de resposta. Ocorre que para que o R entenda este tipo de dado como algo categ\u00f3rico, precisamos transform\u00e1-los em fatores ( factors ). Para fazer essa transforma\u00e7\u00e3o, utilizaremos uma fun\u00e7\u00e3o chamada factor() que recebe como par\u00e2metro um vetor com o que queremos transformar em categorias. factor(c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\")) Diferente de quando executamos um dado tipo texto, os dados categ\u00f3ricos apresentam os n\u00edveis das categorias ( levels ). Perceba que as nossas categorias n\u00e3o est\u00e3o de acordo com o que a escala likert pressup\u00f5e e para arrumar este problema, precisamos definir os n\u00edveis atrav\u00e9s de um outro par\u00e2metro da fun\u00e7\u00e3o factor() chamado levels = . factor(c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\"), levels = c(\"Discordo totalmente\", \"Discordo parcialmente\", \"Indiferente\", \"Concordo parcialmente\", \"Concordo totalmente\")) Pode parecer um pouco confuso agora, mas iremos esclarecer estes pontos nos pr\u00f3ximos t\u00f3picos.","title":"2.3.3. Lidando com vari\u00e1veis do tipo factor (vari\u00e1veis categ\u00f3ricas)"},{"location":"01_introducao/#234-lidando-com-data-e-tempo","text":"Muitas vezes precisamos lidar com data, como por exemplo, filtrar nossa an\u00e1lise em um intervalo de tempo. Por\u00e9m, n\u00fameros e textos n\u00e3o s\u00e3o suficientes para entender as regras impostas pelas datas, como por exemplo, \u201c01/01/2019\u201d \u00e9 mais recente que \u201c31/12/2018\u201d. Sys.Date() Parece uma vari\u00e1vel texto, n\u00e3o? Por\u00e9m se aplicarmos a fun\u00e7\u00e3o class() , que serve para verificarmos o tipo de uma vari\u00e1vel, podemos ver que se trata de uma vari\u00e1vel do tipo Date . Nem sempre teremos que nos preocupar com isso, mas caso voc\u00ea esteja querendo plotar uma s\u00e9rie temporal essa transforma\u00e7\u00e3o \u00e9 bem importante. class(Sys.Date()) !!! note \"Curiosidade\" Caso voc\u00ea tenha ficado curiosa, por baixo a vari\u00e1vel Date \u00e9 do tipo num\u00e9rico e, por conven\u00e7\u00e3o, nada mais \u00e9 do que a quantidade de segundos passados desde 1 de Janeiro de 1970.","title":"2.3.4. Lidando com data e tempo"},{"location":"01_introducao/#235-lidando-com-logicosbooleanos","text":"Valores booleanos s\u00e3o resultados de opera\u00e7\u00f5es booleanas e podem ser definidos como verdadeiros ou falsos . Por conven\u00e7\u00e3o, trabalhamos com os termos em ingl\u00eas. Portanto, TRUE ou FALSE . Por opera\u00e7\u00f5es booleanas, podemos pensar em diferentes testes que tenham necessariamente uma resposta ou verdadeira ou falsa. Por exemplo, 3 \u00e9 maior do que 1? Verdadeiro! E 3 \u00e9 menor do que 2? Falso! Vamos realizar essas duas opera\u00e7\u00f5es no R. # 3 \u00e9 maior do que 1? 3 > 1 # 3 \u00e9 maior do que 1? 3 < 2 Existem, obviamente, outras opera\u00e7\u00f5es. \u00c9 poss\u00edvel tamb\u00e9m testar a igualdade entre dois valores com == . # 2 \u00e9 igual a 2? 2 == 2 Tamb\u00e9m podemos testar se dois valores s\u00e3o diferentes. #120 \u00e9 diferente de 20? 120 != 20 Outras varia\u00e7\u00f5es utilizadas s\u00e3o o maior ou igual ( >= ) e o menor ou igual ( <= ). Al\u00e9m disso, tamb\u00e9m \u00e9 poss\u00edvel realizar essas opera\u00e7\u00f5es com textos. # \"FFLCH\" \u00e9 igual a \"ICB\"? \"FFLCH\" == \"ICB\" !!! question \"Qual texto \u00e9 maior?\" Na sua opini\u00e3o, qual \u00e9 o resultado de \"Acre\" > \"S\u00e3o Paulo\" ? Na pr\u00e1tica, podemos utilizar essas opera\u00e7\u00f5es para filtrar o nosso banco de dados. Imagine, por exemplo, que voc\u00ea possui um banco de dados das elei\u00e7\u00f5es municipais realizadas no Brasil em 2020, mas que quisesse apenas o resultado do Rio de Janeiro. Mediante uma opera\u00e7\u00e3o booleana, podemos fazer algo como cidade == \"Rio de Janeiro\" e selecionar apenas o resultado dessa cidade.","title":"2.3.5. Lidando com l\u00f3gicos/booleanos"},{"location":"01_introducao/#236-valores-ausentes-ou-missing","text":"O que s\u00e3o missing e por que existe um valor especial para eles? Missing representam valores desconhecidos. Imagine que, durante uma pesquisa sobre prefer\u00eancia pol\u00edtica, a pessoa entrevistada se recusa a responder a pergunta \u201cVoc\u00ea votou na \u00faltima elei\u00e7\u00e3o?\u201d. O fato dela se recusar n\u00e3o significa que ela n\u00e3o tenha votada. N\u00f3s simplesmente n\u00e3o sabemos e precisamos representar isso nos nossos dados para tratarmos esses casos eventualmente. Tipos de missing Existem dois tipos de valores missing, o NA ( not available ) e o NaN ( not a number ), ambos tem sentidos semelhantes, por\u00e9m o primeiro \u00e9 mais gen\u00e9rico para cada tipo de dado. Para sabermos se um certo dado \u00e9 missing , utilizamos a fun\u00e7\u00e3o is.na() . is.na(NA) is.na(99) Por que esse c\u00f3digo retorna NA ? NA == NA","title":"2.3.6. Valores Ausentes ou Missing"},{"location":"01_introducao/#3-exercicios-parte-1","text":"","title":"3. Exerc\u00edcios - Parte 1"},{"location":"01_introducao/#31-tipos-de-dados","text":"Quais os tipos de cada vari\u00e1vel apresentada abaixo? !!! warning \"\" Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 33.5 20 \"Ol\u00e1 mundo!\" factor(\"oi\", levels = c(\"oi\", \"tchau\")) TRUE FALSE","title":"3.1. Tipos de Dados"},{"location":"01_introducao/#32-encontre-o-erro","text":"Verifique se as express\u00f5es abaixo s\u00e3o v\u00e1lidas ou n\u00e3o. Caso n\u00e3o sejam, reescreva-as de maneira que sejam v\u00e1lidas. !!! warning \"\" Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 22,2 'O 'R' \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal'","title":"3.2. Encontre o erro"},{"location":"01_introducao/#4-estruturas-de-dados","text":"As estruturas de dados s\u00e3o maneiras de organizar e guardar dados dentro da linguagem para que possamos trabalhar de forma mais eficiente. No nosso cotidiano utilizaremos tr\u00eas destas estruturas: vetores e dataframes .","title":"4. Estruturas de dados"},{"location":"01_introducao/#41-vetores","text":"Um vetor at\u00f4mico \u00e9 a estrutura mais b\u00e1sica no R; \u00e9 um vetor de dados homog\u00eaneo com apenas uma dimens\u00e3o. Imagine o vetor como um trem cujos valores est\u00e3o ordenados e s\u00e3o obrigatoriamente do mesmo tipo ( numeric ). Ilustra\u00e7\u00e3o de um trem Que tal um exemplo? Imagine que voc\u00ea queira organizar em um vetor a quantidade de pessoas dentro de vag\u00f5es de um trem. Nesse sentido, a quantidade de pessoas no primeira vag\u00e3o \u00e9 seguida da quantidade de pessoas no segundo e assim por diante. c(120, 29, 191, 18, 39) Quantas pessoas est\u00e3o no segundo vag\u00e3o? 29? Acertou! Perceba ent\u00e3o que para construir um vetor basta colocarmos os valores dentro de c() .","title":"4.1. Vetores"},{"location":"01_introducao/#411-indexando-vetores","text":"!!! warning \"\" Se voc\u00ea tem experi\u00eancia com programa\u00e7\u00e3o, o R \u00e9 diferent\u00e3o dentro desse mundo. Todas as estruturas s\u00e3o indexadas a partir do valor 1 , ou seja, para acessar o primeiro valor de um vetor, voc\u00ea executar\u00e1 algo como vetor[1] . Podemos acessar os valores espec\u00edficos de um vetor a partir da posi\u00e7\u00e3o dele nessa estrutura. No exemplo anterior, voc\u00ea poderia ter pedido para o R lhe retornasse quem est\u00e1 na segunda posi\u00e7\u00e3o. Para isso, basta utilizar trem[2] como no exemplo a seguir. trem <- c(120, 29, 191, 18, 39) trem[2] Para indexarmos mais de um elemento podemos indexar de duas formas. Logo se quis\u00e9ssemos o n\u00famero de pessoas no terceiro e quarto vag\u00e3o: trem[c(3,4)] trem[3:4] O que acontece se voc\u00ea utilizar [3:5] ? trem[3:5]","title":"4.1.1. Indexando vetores"},{"location":"01_introducao/#42-dataframes","text":"O dataframe \u00e9 semelhante a uma planilha de Excel ou Google Sheets. Ela \u00e9 uma representa\u00e7\u00e3o feita dentro do R para estruturas que possuem linhas e colunas. As colunas, no geral, ser\u00e3o as nossas vari\u00e1veis, as informa\u00e7\u00f5es sobre uma determinada unidade observacional (pessoas, estados, pa\u00edses, etc.), enquanto cada linha representa uma observa\u00e7\u00e3o. Por exemplo, caso fiz\u00e9ssemos um dataframe com informa\u00e7\u00f5es sobre os pa\u00edses do mundo, cada linha seria um pa\u00eds e cada coluna uma informa\u00e7\u00e3o sobre esse ele. tabela <- data.frame(ano = c(2014, 2014, 2015, 2015, 2016, 2016), pais = c('Brasil', 'China', 'Brasil', 'China', 'Brasil', 'China'), pib = c(100,130, 110, 140, 160, 170), pop = c(3, 8, 4, 9, 6, 14)) tabela Diferentemente do Excel, n\u00e3o podemos selecionar uma c\u00e9lula e alterar um dado. No R, para manipular e visualizar uma tabela precisamos utilizar fun\u00e7\u00f5es. N\u00e3o se estresse caso nunca tenho ouvido falar delas. Pense apenas que elas realizam alguma a\u00e7\u00e3o . Repare nos resultados das fun\u00e7\u00f5es a seguir: View(tabela) # mostra o banco no console head (tabela) # mostra as seis primeiras linhas do banco no console str(tabela)# mostra a estrutura da tabela names(tabela) # mostra o nome das vari\u00e1veis nrow(tabela) # n\u00ba de linhas ncol(tabela) #n\u00ba de colunas dim(tabela) # dimens\u00f5es","title":"4.2. Dataframes"},{"location":"01_introducao/#431-indexando","text":"Para indexar dataframes , voc\u00ea precisa levar em conta a caracter\u00edstica bidimensional dessa estrutura de dados. Uma tabela ser\u00e1 indexada com tabela[linha, coluna] . tabela[1, 2] # Primeira linha, segunda coluna tabela[1,] # Primeira linha, todas as colunas tabela[,1] # Todas as linhas, primeira coluna tabela[1:3,] # Linhas de 1 at\u00e9 3, todas as colunas tabela[,2:4] # todas as linhas, colunas de 2 at\u00e9 4 Como dataframes possuem colunas e as colunas, nomes, podemos utilizar o nome das colunas para selecion\u00e1-las. tabela[,\"pais\"] # Todas as linhas da coluna \"pais\" tabela[2,\"pais\"] # O valor da segunda linha e da coluna \"pais\" tabela[, c(\"pais\", \"pib\")] # Todas as linhas das colunas \"pais\" e \"pib\" Por fim, tamb\u00e9m podemos indexar utilizando o operador $ seguido do nome da coluna. tabela$pib tabela$pib[1]","title":"4.3.1. Indexando"},{"location":"01_introducao/#432-importando-dataframes-csv-excel-etc","text":"Uma das maneiras mais eficientes de se importar dados para o R \u00e9 pelo uso dos seguintes pacotes: readr para a leitura de CSVs. readxl para a leitura de planilhas de Excel. haven para a leitura de arquivos. Instalando pacotes do R O R n\u00e3o possui todos os pacotes previamente. Em geral, utilizaremos o comando install.packages() para instalar pacotes no R. Execute o comando install.packages(c('readr', 'readxl', 'haven')) . Lembre-se de carregar o pacote no R com o comando library() . Por exemplo, library(readr) . Voc\u00ea sabia que o TSE (Tribunal Superior Eleitoral) libera diversos dados sobre as elei\u00e7\u00f5es no site deles? Que tal tentar baixar o banco de candidatos? Para isso, baixe os arquivos: Candidatos - CSV Candidatos - CSV2 Candidatos - TAB Candidatos - Arroba Candidatos - Excel Candidatos - Stata \u00c0s vezes, o navegador n\u00e3o ir\u00e1 fazer o download automaticamente (normalmente isso ocorre no Firefox) e lhe mostrar\u00e1 uma tela repleta de caracteres. Calma! Clique com o bot\u00e3o direito na tela e selecione a op\u00e7\u00e3o Save Page As\u2026 . Recomendamos que voc\u00ea salve os dados dentro de uma pasta chamada data ou dados para manter o projeto organizado. Para importar um CSV para o R, utilize a fun\u00e7\u00e3o read_csv() do pacote readr . Fique atento com o lugar que voc\u00ea salvou os arquivos! Neste exemplo, os arquivos est\u00e3o salvos dentro da pasta data . library(readr) banco_virgula <- read_csv('data/candidatos_sp_virgula.csv') Se tudo tiver dado certo, agora voc\u00ea ter\u00e1 um banco_virgula no seu ambiente de vari\u00e1veis. Mas nem sempre um banco de dados \u00e9 separado por v\u00edrgula e mesmo assim ele pode ter a extens\u00e3o .csv . Bancos separados por ponto e v\u00edrgula ; . banco_pontovirgula <- read_csv2('data/candidatos_sp_pontovirgula.csv') Banco separados por tabs \\t . banco_tab <- read_tsv('data/candidatos_sp_tab.csv') Banco separados por @ ou qualquer outro caractere . banco_arroba <- read_delim('data/candidatos_sp_arroba.csv', delim = '@') Banco Excel. library(readxl) banco_excel <- read_excel('data/candidatos_sp_excel.xlsx') Repare que o n\u00famero de linhas do banco Excel \u00e9 menor! Por que isso aconteceu? Banco Excel - Abas library(readxl) banco_excel_1 <- read_excel('data/candidatos_sp_excel.xlsx', sheet = 1) banco_excel_1 <- read_excel('data/candidatos_sp_excel.xlsx', sheet = 2) Banco Stata library(haven) banco_stata <- read_stata('data/candidatos_sp_stata.dta')","title":"4.3.2. Importando dataframes (csv, Excel, etc.)"},{"location":"01_introducao/#5-exercicio-parte-2","text":"","title":"5. Exerc\u00edcio - Parte 2"},{"location":"01_introducao/#51-dataframes","text":"Crie um dataframe com o \u201cnome\u201d, \u201cidade\u201d e \u201cfilme\u201d preferido dos seus colegas de turma. Como criar um dataframe? Lembre-se que para criar um dataframe utilizamos a fun\u00e7\u00e3o data.frame() e que essa fun\u00e7\u00e3o recebe vetores como par\u00e2metros para cada coluna que desejamos criar. Por exemplo, se voc\u00ea quiser criar uma dataframe com uma lista de n\u00fameros basta executar data.frame(lista_numeros = c(1,2,3,4,5,6,7)) No R temos, bancos para fins did\u00e1ticos. Para utiliz\u00e1-los basta usar a fun\u00e7\u00e3o data. Para esse exerc\u00edcios utilizaremos o banco mtcars. Execute data(mtcars) . Repare que agora voc\u00ea pode acessar o banco mtcars da mesma maneira que fizemos anteriormente com outros dataframes. Visualize o banco. Do que se trata? Quais s\u00e3o suas vari\u00e1veis? E suas dimens\u00f5es? Selecione as 10 primeiras observa\u00e7\u00f5es","title":"5.1. DataFrames"},{"location":"01_introducao/#5-funcoes","text":"Como voc\u00ea deve ter notado mencionamos algumas vezes a palavra fun\u00e7\u00e3o durante o texto. Mas o que \u00e9 isso? Podemos pensar cada fun\u00e7\u00e3o como uma a\u00e7\u00e3o . Por exemplo, imagine voc\u00ea possa controlar a sua vida por meio de fun\u00e7\u00f5es . Se as coisas funcionam assim, provavelmente ter\u00edamos uma fun\u00e7\u00e3o levantar() , beber_aguar() e assim por diante. No R, o princ\u00edpio \u00e9 o mesmo e precisamos utilizar fun\u00e7\u00f5es para executar quaisquer comandos que precisamos que sejam operados. Por exemplo, quando voc\u00ea executou read_csv() , voc\u00ea chamou um c\u00f3digo que abre o arquivo especificado e estrutura cada linha dentro de um dataframe. Mas como uma fun\u00e7\u00e3o sabe sobre onde ela precisa operar? Como read_csv() sabia que precisava abrir aquele arquivo? Para isso, utilizamos par\u00e2metros . Par\u00e2metros alteram o comportamento das nossas fun\u00e7\u00f5es e nos permitem especificar, por exemplo, um arquivo para a read_csv() escrevendo read_csv('arquivo.csv') . Vamos ver isso na pr\u00e1tica com outra fun\u00e7\u00e3o bastante importante, a mean() . Como aprender a utilizar fun\u00e7\u00f5es? Obviamente, voc\u00ea pode utilizar o Google, mas muitas vezes n\u00e3o \u00e9 necess\u00e1rio sair do RStudio. Se voc\u00ea quiser, utilize o comando ?mean e tente ler a documenta\u00e7\u00e3o e os exemplos. Pacotes instalados pelo CRAN necessariamente s\u00e3o acompanhados por uma documenta\u00e7\u00e3o que explica o que as suas fun\u00e7\u00f5es fazem. Vamos tentar rodar um exemplo? x <- c(1,2,3) xm <- mean(x) xm A fun\u00e7\u00e3o mean() calcula a m\u00e9dia de qualquer vetor num\u00e9rico para a gente e podemos utilizar para ter uma no\u00e7\u00e3o dos nossos dados durante uma an\u00e1lise.","title":"5. Fun\u00e7\u00f5es"},{"location":"01_introducao/#51-pacotes","text":"Segundo a defini\u00e7\u00e3o do livro R Packages, escrito por Hadley Wickham, um pacote \u00e9 uma unidade fundamental de compartilhamento de c\u00f3digos, dados, documenta\u00e7\u00e3o e testes. Em outras palavras, os pacotes s\u00e3o cole\u00e7\u00f5es de c\u00f3digos (fun\u00e7\u00f5es) e dados desenvolvidos pela comunidade. Estes pacotes ficam localizados no que chamamos de reposit\u00f3rio. O principal reposit\u00f3rio recebe o nome de C omprehensive R A rchive N etwork, o tamb\u00e9m chamado, CRAN. Mas existem outros tamb\u00e9m, como o Github, no qual a forma de obter os pacotes muda. Para instalar um pacote, utilize o comando install.packages() em que o argumento principal \u00e9 o nome do pacote que queremos instalar. Uma peculiaridade desta fun\u00e7\u00e3o \u00e9 que por padr\u00e3o ela instala os pacotes que est\u00e3o no CRAN, como por exemplo, vamos instalar um pacote chamado \u201cdplyr\u201d install.packages(\"dplyr\") Ap\u00f3s instalarmos o pacote, devemos habilit\u00e1-lo com uma fun\u00e7\u00e3o chamada library() library(dplyr) Caso o pacote n\u00e3o esteja no CRAN, mas sim no Github, devemos instalar o pacote com o auxilio de uma fun\u00e7\u00e3o chamada install_github() do pacote devtools . install.packages(\"devtools\") library(devtools) Pacotes no GitHub Caso o seu pacote n\u00e3o esteja liberado no CRAN ou caso deseje ter acesso \u00e0 vers\u00e3o de desenvolvimento, voc\u00ea ir\u00e1 precisar utilizar a fun\u00e7\u00e3o install_github() do pacote devtools que recebe como par\u00e2metro <dono-do-pacote>/<nome-do-pacote> . Por exemplo, install_github(\"abjur/abjutils\") . N\u00e3o se esque\u00e7a de habilitar o devtools com a fun\u00e7\u00e3o library(devtools) .","title":"5.1. Pacotes"},{"location":"01_introducao/#6-controladores-de-fluxo","text":"\u00c9 muito comum estabelecermos uma condi\u00e7\u00e3o para tomar uma decis\u00e3o, como por exemplo, \u2018Porcentagem de votos maior que 50% pode significar vit\u00f3ria, caso contr\u00e1rio, derrota\u2019. Para que possamos fazer isso, utilizaremos o if/else e o for !","title":"6. Controladores de Fluxo"},{"location":"01_introducao/#61-ifelse","text":"A estrutura do if/else \u00e9 a seguinte: if(<condicao>){ <comando1> <comando2> <etc> }else{ <comando3> <comando4> <etc> } Podemos interpret\u00e1-la da seguinte maneira: Se a condi\u00e7\u00e3o for verdadeira, execute os comandos 1 e 2, caso contr\u00e1rio, execute os comandos 3 e 4.","title":"6.1. if/else"},{"location":"01_introducao/#62-for","text":"for (i in x){ <comando1> <comando2> } N\u00f3s lemos o for acima da seguinte maneira: Para cada valor \u201ci\u201d presente na sequ\u00eancia \u201cx\u201d, realize tais comandos. Ou seja, para cada linha da nossa tabela, some um ao percentual de votos recebidos. Vamos criar o seguinte dataframe : ano : ano da observa\u00e7\u00e3o. pais : pa\u00eds da observa\u00e7\u00e3o. pip : Produto Interno Bruto do pa\u00eds. pop : Popula\u00e7\u00e3o do pa\u00eds. tabela <- data.frame(ano = c(2014, 2014, 2015, 2015, 2016, 2016), pais = c('Brasil', 'China', 'Brasil', 'China', 'Brasil', 'China'), pib = c(100,130, 110, 140, 160, 170), pop = c(3, 8, 4, 9, 6, 14)) Nosso objetivo: Criar uma terceira coluna com o PIB per capta com um for for(i in 1:nrow(tabela)){ print(tabela$pib[i]) } Vamos entender algumas coisas aqui, nrow(tabela) \u00e9 uma fun\u00e7\u00e3o que retorna o n\u00famero de linhas de uma tabela, ou seja, seu resultado \u00e9 um n\u00famero. Quando temos 1:nrow(tabela) , estamos criando um vetor com uma sequ\u00eancia de 1 at\u00e9 o n\u00famero de linhas da nossa tabela, no caso, 6. Isso significa que nosso for vai percorrer as treze linhas da tabela. Uma vez que o i assumir\u00e1 os valores de 1 at\u00e9 6, podemos indexar o vetor tabela$pip[i] com o [i] para obter o n\u00famero do PIB correspondente a linha i . Dessa maneira podemos dividir tabela$pip[i] pela tabela$pop[i] e obter a _renda per capta. Vamos agora voltar ao nosso objetivo principal: tabela$pib_capta <- NA # Criando uma coluna vazia for(i in 1:nrow(tabela)){ tabela$pib_capta[i] <- tabela$pib[i] / tabela$pop[i] } print(tabela) Por fim, n\u00f3s podemos misturar o for com o if para obter um comportamento customiz\u00e1vel dentro do nosso loop . Por exemplo, vamos criar uma classifica\u00e7\u00e3o de PIB per capta entre alto e baixo. Para isso, iremos utilizar o 20 como o discriminador entre essas duas classes. Nesse sentido, se pib_capta for maior do que 20 devemos classificar tabela$pip_capta_class <- NA # Criando uma coluna vazia for(i in 1:nrow(tabela)){ if(tabela$pib_capta[i] > 20){ tabela$pip_capta_class[i] <- 'Alto' } else { tabela$pip_capta_class[i] <- 'Baixo' } } print(tabela) PARAB\u00c9NS!!! :tada: :tada: :tada: Enfim, ap\u00f3s esse breve resumos de conceitos b\u00e1sicos de programa\u00e7\u00e3o voc\u00ea ser\u00e1 capaz de interagir com pacotes com uma vasta variedade de pacotes, al\u00e9m de conseguir desenvolver as pr\u00f3prias solu\u00e7\u00f5es quando for necess\u00e1rio.","title":"6.2. for"},{"location":"01_introducao/#7-exercicios","text":"","title":"7. Exerc\u00edcios"},{"location":"01_introducao/#exercicio-1-tipos-de-dados","text":"Execute os c\u00f3digos abaixo e verifique se s\u00e3o dados v\u00e1lidos em R. Caso verdadeiro, informe o tipo de dado: Obs: Caso apare\u00e7a \u201c+\u201d no seu console ao testar as afirma\u00e7\u00f5es, basta apertar \u201cEsc\u201d 33,5 \"Ol\u00e1 mundo\" \"O 'R' \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal\" \"O 'R \u00e9 uma linguagem legal' 400e + 10 factor(\"oi\", levels = c(\"oi\", \"tchau\")) true False","title":"Exerc\u00edcio 1 - Tipos de dados"},{"location":"01_introducao/#exercicio-2-manipulando-variaveis","text":"Altere o valor de v_numero para 42 v_numero <- 42.5 Altere o valor de v_caractere para \u201cuniverso\u201d. v_caractere <- \"algum texto\"` Altere o valor de v_logical para FALSE `v_logical <- TRUE`","title":"Exerc\u00edcio 2 - Manipulando vari\u00e1veis"},{"location":"01_introducao/#exercicio-3-estruturas-de-dados","text":"Crie dois vetores: O primeiro ( nome ) deve conter o nome de pelo menos 5 colegas que est\u00e3o sentandos ao seu redor. O segundo ( altura ) deve conter a altura desses colegas. vetor_nome <- c() vetor_altura <- c() Acesse o primeiro nome do vetor_nome . Lembre-se que voc\u00ea precisa dos [] . Acesse os primeiros tr\u00eas valores de altura no vetor_altura . Fa\u00e7a isso apenas utilizando [] e : Fa\u00e7a isso apenas utilizando [] e c() Crie um dataframe a partir de vetor_nome e vetor_altura . tabela_colegas <- data.frame(nome = <completar>, altura = <completar>) Usando a indexa\u00e7\u00e3o , obtenha: O vetor nome dentro do dataframe tabelas_colegas O vetor altura dentro do dataframe tabelas_colegas Obtenha a primeira observa\u00e7\u00e3o da sua tabela (primeira linha) Utilizando fun\u00e7\u00f5es obtenha: A m\u00e9dia de altura dos seus colegas Uma tabela ( table() ) dos nomes dos seus colegas O desvio padr\u00e3o da altura ( sd() )","title":"Exerc\u00edcio 3 - Estruturas de Dados"},{"location":"01_introducao/#exercicio-4-controladores-de-fluxo","text":"Imprima todas as alturas de tabelas_colegas com for e print() . Crie uma classifica\u00e7\u00e3o para a altura dos seus colegas com for e if . N\u00e3o se preocupe com o valor utilizado. Contudo, case deseje, voc\u00ea pode dividi-los pela mediana ou pela m\u00e9dia .","title":"Exerc\u00edcio 4 - Controladores de Fluxo"},{"location":"01_introducao/#exercicio-5-importacao-de-dados","text":"Escolha um dos bancos abaixo ou qualquer outro de seu interesse. Baixe o banco, utilize as fun\u00e7\u00f5es para explorar as vari\u00e1veis, retire algum resumo de uma vari\u00e1vel (m\u00e9dia, contagem, etc.). Relembrando as fun\u00e7\u00f5es Voc\u00ea pode utilizar View() , head() , str() , names() , entre outras para ter uma ideia geral do banco de dados. Para extrair estat\u00edsticas, voc\u00ea pode utilizar mean() , sd() , median() , etc. Lembre-se que o Google \u00e9 o seu melhor amigo! Pesquisa outros comandos que sejam do seu interesse! Banco Link Banco Elei\u00e7\u00f5es Download Pre\u00e7o M\u00e9dio de Combust\u00edveis no Brasil Download Banco de Pokemon Download Vagas de Emprego em Nova Iorque Download","title":"Exerc\u00edcio 5 - Importa\u00e7\u00e3o de Dados"},{"location":"01_introducao/#exercicio-6-desafio","text":"Com o banco de dados do exerc\u00edcio anterior tente levantar algumas hip\u00f3teses sobre as rela\u00e7\u00f5es de vari\u00e1veis. Por exemplo, \u201ceu acho que X causa Y\u201d. Anote todas essas hip\u00f3teses. Uma vez feito isso, tente: Criar um gr\u00e1fico que ressalte a rela\u00e7\u00e3o entre essas vari\u00e1veis. Procure rodar um teste estat\u00edstico que ponha \u00e0 prova a sua hip\u00f3tese (Teste t, ANOVA, regress\u00e3o linear, regress\u00e3o log\u00edstica, etc.). Por onde come\u00e7ar? Existe um pacote de visualiza\u00e7\u00e3o de dados muito famoso para o R chamado ggplot2 . Quanto ao teste estat\u00edstico, o R possu\u00ed todos os testes citados implementados, ou seja, voc\u00ea n\u00e3o precisa baixar um pacote para aplic\u00e1-los. Tente procurar na internet . Existem refer\u00eancias tanto em portugu\u00eas quanto em ingl\u00eas .","title":"Exerc\u00edcio 6 - Desafio"},{"location":"02_estruturar/","text":"Hoje, vamos trabalhar com um banco de dados sobre doen\u00e7as card\u00edacas . O dado est\u00e1 dispon\u00edvel UCI - Machine Learning Repository e no Kaggle . Os respons\u00e1veis pelo estudo foram as seguintes entidades: Hungarian Institute of Cardiology. Budapest: Andras Janosi, M.D. University Hospital, Zurich, Switzerland: William Steinbrunn, M.D. University Hospital, Basel, Switzerland: Matthias Pfisterer, M.D. V.A. Medical Center, Long Beach and Cleveland Clinic Foundation: Robert Detrano, M.D., Ph.D. A diagn\u00f3stico de doen\u00e7a card\u00edaca foi feita a partir de uma angiografia. Se houvesse estreitamento maior do que 50% para pelo menos um vaso sangu\u00edneo principal, o paciente foi classificado como portador de doen\u00e7a card\u00edaca. Caso contr\u00e1rio, o paciente n\u00e3o foi diagnosticado com a doen\u00e7a. Vari\u00e1vel Descri\u00e7\u00e3o age_sex Idade - Sexo cp Tipo de dor no peito trestbps Press\u00e3o sangu\u00ednea (mm Hg) em descanso chol Colesterol (mg/dl) fbs A\u00e7\u00facar no sangue em jejum maior do que 120mg/dl (1 = Sim, 0 = N\u00e3o) restecg Resultados eletrocardiogr\u00e1ficos em repouso thalach Maior ritmo card\u00edaco atingido exang Angina induzida por exerc\u00edcio ca N\u00famero de vasos principais coloridos por flourosopy target Diagn\u00f3stico de doen\u00e7a card\u00edaca (1 = Sim, 0 = N\u00e3o) Vamos come\u00e7ar, ent\u00e3o? Download do Banco O banco hoje est\u00e1 em formato Excel. Voc\u00ea sabe qual fun\u00e7\u00e3o e pacote utilizamos para abrir esse arquivo? library(<pacote>) banco <- <funcao>(<caminho_do_arquivo>) 1. tidyr O tidyr \u00e9 o pacote utilizado para estruturar os nossos bancos de dados. Em geral, ele pode ser utilizado para unir ( unite ) e separar ( separate ) colunas ou para derreter ( gather ) e esticar ( spread ) as colunas. Esse pacote \u00e9 constru\u00eddo com base no conceito de tidy data . Deixar os seus dados tidy significa transformar a estrutura deles de tal maneira que tenhamos observa\u00e7\u00f5es nas linhas, vari\u00e1veis nas colunas e valores nas c\u00e9lulas. Em geral, esperamos tamb\u00e9m que um banco tidy contenha apenas uma unidade de observa\u00e7\u00e3o, granularidade, etc. Ilustra\u00e7\u00e3o do Tidy Data (Fonte: http://statseducation.com ) O que \u00e9 unidade de observa\u00e7\u00e3o / granularidade? Trata-se da unidade contida nas linhas do seu banco. Por exemplo, se montarmos um banco de dados com informa\u00e7\u00f5es sobre pessoas (altura, idade, peso, etc.) em cada linha teremos pessoas como unidade de observa\u00e7\u00e3o. Qual a unidade de observa\u00e7\u00e3o do nosso banco? 1.1 separate() Instalando pacotes Caso voc\u00ea n\u00e3o tenha o tidyr ou o tibble no seu computador, por favor, execute o c\u00f3digo install.packages(c('tidyr', 'tibble')) . separate() \u00e9 uma fun\u00e7\u00e3o do pacote tidyr que tem como objetivo separar valores contidos em uma coluna. \u00c0s vezes, mais de uma informa\u00e7\u00e3o \u00e9 agrupado dentro da mesma vari\u00e1vel. Repare no exemplo abaixo. exemplo_separete <- tibble::tribble( ~ CIDADE , ~MORTALIDADE, 'S\u00e3o Jos\u00e9 dos Campos - SP', 80, 'Porto Alegre - RS', 100, 'Bras\u00edlia - DF', 81 ) exemplo_separete Qual vari\u00e1vel cont\u00e9m mais de uma informa\u00e7\u00e3o? Por mais que talvez voc\u00ea tenha o costume de agrupar a sua cidade \u00e0 unidade federativa dela, esses dois valores dizem respeito a qualidades diferentes da nossa oberva\u00e7\u00e3o. Imagine que o banco se estendesse para todas as cidades brasileiras. Como far\u00edamos para identificar as unidades federativas com maior m\u00e9dia de mortalidade? Como aplicar a fun\u00e7\u00e3o separate() ? Antes de tudo, tente executar o comando ?separate . A documenta\u00e7\u00e3o do tidyr tende a ser muito boa e normalmente teremos uma boa explica\u00e7\u00e3o de como a fun\u00e7\u00e3o opera e de quais par\u00e2metros precisamos utilizar nela. No caso, o separate() recebe (1) no primeiro par\u00e2metro o banco de dados, (2) no segundo, a coluna que desejamos separar, (3) na terceira o nome das colunas que desejamos criar a partir da coluna informada no segundo par\u00e2metro, (4) o separador, ou seja, o padr\u00e3o de caracteres que ser\u00e3o utilizados para separar a coluna do segundo par\u00e2metro nas colunas especificadas no terceiro par\u00e2metro. Isso pode parecer complicado, mas \u00e9 bem simples. separate(<dataframe>, <coluna_que_desejamos_separar>, <vetor_com_as_colunas_a_serem_criadas>, <separador>) Tente fazer sozinho. Reposta : separate(exemplo_separete, 'CIDADE', c('CIDADE', 'UF'), '-') 1.1.1. Aplicando no nosso banco Voc\u00ea consegue descobrir qual vari\u00e1vel no nosso banco tem esse problema? Fun\u00e7\u00f5es para explorar dataframes Tente utilizar fun\u00e7\u00f5es para explorar o seu dataframe. Por exemplo, com head() conseguimos obter facilmente as primeiras linhas do nosso banco. Voc\u00ea percebeu alguma coisa de estranho na vari\u00e1vel age_sex ? O que? age_sex cont\u00e9m dois tipos de informa\u00e7\u00f5es diferentes. De um lado, temos a idade da pessoa. Do outro, temos o sexo dessa pessoa. Novamente, precisamos separar essas duas informa\u00e7\u00f5es em duas vari\u00e1veis para que possamos prosseguir com a nossa an\u00e1lise. Vamos l\u00e1? Agora \u00e9 a sua vez. Como precisamos fazer para separar as duas vari\u00e1veis? \ud83d\udcaa PS: N\u00e3o se preocupe com o remove = FALSE . Utilizamos esse par\u00e2metro apenas para manter a vari\u00e1vel antiga e sermos capazes de validar o nosso resultado. separate(<banco>, <variavel>, <vetor>, <sep>, remove = FALSE) Que tal dar um View() no seu banco agora? View(banco) Salvando altera\u00e7\u00f5es Nunca se esque\u00e7a de que o R n\u00e3o sabe que voc\u00ea deseja sobrescrever uma vari\u00e1vel. Ao contr\u00e1rio do Stata, por exemplo, as altera\u00e7\u00f5es devem ser escritas sobre uma vari\u00e1vel com <- . Caso contr\u00e1rio, o R ir\u00e1 apenas imprimir no console o resultado. Agora, podemos utilizar o View() ou o head() para verificar se deu tudo certo. 1.2. unite A fun\u00e7\u00e3o unite() tem o comportamento inverso separate() . N\u00f3s a utilizamos para unir valores que fazem mais sentido juntos do que separados. Repare no exemplo abaixo. O que voc\u00ea faria para obter em uma \u00fanica vari\u00e1vel uma informa\u00e7\u00e3o mais precisa? exemplo_unite <- tibble::tribble( ~ID,~DIA, ~MES, ~ANO, ~DOSE_REMEDIO, ~RESULTADO, 1, 14, 8, 2018, 1, 0, 1, 15, 8, 2018, 2, 0, 2, 9, 7, 2018, 1 ,0, 2, 10, 7, 2018, 2, 0, 2, 11, 7, 2018, 3, 1 ) exemplo_unite Ap\u00f3s executar o c\u00f3digo acima, vamos prosseguir com a fun\u00e7\u00e3o unite() . Ela recebe (1) no primeiro par\u00e2metro o banco de dados e (2) no segundo o nome da nova vari\u00e1vel. Em seguida, (3) adicionamos todas as colunas que queremos concatenar (4) e, por fim, podemos escolher o separador entre as colunas. unite(<banco>, <nome_da_nova_variavel>, sep = '<separador>') Vamos tentar sozinho primeiro? Resposta : banco <- unite(exemplo_unite, \"DATA\", ANO, MES, DIA, sep = \"-\") Verifique o resultado com a fun\u00e7\u00e3o head() . 1.2.1. Aplicando no nosso banco Que tal arrumar, agora, o nosso banco de dados tamb\u00e9m? Lembre-se que \u00e9 poss\u00edvel utilizar a as fun\u00e7\u00f5es head() , str() , entre outras para ter uma ideia geral da estrutura do nosso dataframe . Provavelmente, voc\u00ea reparou que existem tr\u00eas vari\u00e1veis que, na verdade, fornam uma \u00fanica: birth_day , birth_month e birth_year . Que tal tentar uni-las com a fun\u00e7\u00e3o separate() ? 2. Exerc\u00edcios - Parte 1 N\u00f3s acabamos de aprender a estruturar o nosso banco no que diz respeito a unir e separar vari\u00e1veis. Vamos praticar mais um pouco? 2.1. Exerc\u00edcio - Exemplos de unite e separate Para cada tabela abaixo (1) diga se \u00e9 necess\u00e1rio realizar um unite() ou um separate() e (2) escreva o c\u00f3digo que corrija esse problema. Item I : ex2_1_1 <- tibble::tribble( ~ANO, ~RAZAO_DE_HOMICIDIO, 2014, '1200293 / 102000000', 2015, '201992 / 102929222', 2016, '203918 / 175999271', 2017, '2901827 / 228191900', 2018, '201928 / 201928238', ) Item II : ex_2_1_2 <- tibble::tribble( ~NOME, ~LOGRADOUR, ~NUMERO, ~COMPLEMENTO, 'Lyandra', 'Rua Ademar de Barros', 20, 'APT 28', 'Monica', 'Avenida S\u00e3o Pedro', 30, 'BLOCO A', 'Luis', 'Rua do Lago', 22, 'Port\u00e3o do lado esquerdo', 'Isaac', 'Avenida Paulista', 22, 'APT 102', 'S\u00f4nia', 'Rua Brigadeiro', 982, 'APT 283' ) Item III : ex_2_1_3 <- tibble::tribble( ~ID, ~DIA, ~MES, ~ANO, ~ALTURA_PESO, 1, 10, 2, 1998, '180 - 340', 2, 11, 2, 1998, '190 - 200', 3, 20, 3, 1998, '188 - 176', 2, 30, 5, 1998, '192 - 180' ) Parab\u00e9ns! :tada: :tada: :tada: 3. Gather e Spread Voc\u00ea j\u00e1 ouviu falar em bancos no formato wide e long ? Mortalidade na China e no Brasil - Wide Pa\u00eds 2015 2016 Brasil 12 12.2 China 20 30 Mortalidade na China e no Brasil - Long Pa\u00eds Ano Mortalidade Brasil 2015 12 Brasil 2016 12.2 China 2015 20 China 2016 30 Qual a diferen\u00e7a entre os dois bancos? Quais deles est\u00e1 no formato tidy ? Se poss\u00edvel escreva ou tente explicar em voz alta. Como o primeiro banco n\u00e3o cont\u00e9m apenas uma oberva\u00e7\u00e3o por linha, ele n\u00e3o \u00e9 tidy . Voc\u00ea concorda que as tomadas de dados sobre mortalidade sobre dois anos n\u00e3o podem ocorrer simultaneamente no mesmo ano? Al\u00e9m disso, 2015 e 2016 est\u00e3o ocupando a posi\u00e7\u00e3o de vari\u00e1veis, mas elas na verdade s\u00e3o valores de uma outra vari\u00e1vel? Voc\u00ea sabe dizer qual? O exemplo de banco tidy \u00e9 o segundo. Nele, temos as vari\u00e1veis claramente denominadas no cabe\u00e7alho do nosso banco. Pa\u00eds \u00e9 uma vari\u00e1vel, assim como Ano e Mortalidade . E cada linha possui uma \u00fanica observa\u00e7\u00e3o. Que fique bem claro: tidy n\u00e3o \u00e9 uma defini\u00e7\u00e3o de qualidade do banco. Apenas tentamos estruturar a nossa tabela nesse formato porque isso torna mais f\u00e1cil a intera\u00e7\u00e3o com outras fun\u00e7\u00f5es (ex. dplyr , ggplot , etc.). 3.1. gather() gather() \u00e9 utilizado para derreter/agrupar as colunas dos nossos bancos. Pensando no exemplo anterior, essa fun\u00e7\u00e3o transforma o nosso banco wide em um banco long . tabela_wide <- tibble::tribble( ~Pa\u00eds , ~`2015`, ~`2016`, 'Brasil' , 10.2 , 11.2, 'China' , 14.3 , 18.4, ) tabela_wide gather() recebe (1) o banco de dados, (2) o nome da vari\u00e1vel ( key ) que est\u00e1 como nome das colunas, (3) o nome da vari\u00e1vel que est\u00e1 nas c\u00e9lulas, (4) os nomes das colunas em que iremos realizar a opera\u00e7\u00e3o sem aspas . gather(<banco>, <key>, <value>, <VAR1>, <VAR2>, <VARn>) Dado isso, qual c\u00f3digo devemos utilizar para realizar a transforma\u00e7\u00e3o em tabela_wide . Resposta : gather(tabela_wide, key = 'ano', value = 'mortalidade' ,`2015`, `2016`) 3.1.1. Aplicando Como o nosso banco n\u00e3o possui esse problema, vamos fingir que decidimos realizar uma segunda coleta de dados e queremos avaliar a evolu\u00e7\u00e3o de doen\u00e7as card\u00edacas nossos pacientes ap\u00f3s 1 ano. Por\u00e9m, o seu estagi\u00e1rio era pregui\u00e7oso e ao inv\u00e9s de estruturar o seu banco no formato tidy ele (1) alterou o nome da coluna target para target2018 e (2) criou uma coluna target2019 para os novos resultados ex3_1_1 <- tibble::tribble( ~ID, ~target2018, ~target2019, 1, 0, 0, 2, 1, 1, 3, 1, 1, 4, 1, 1, 5, 1, 0, ) ex3_1_1 Qual c\u00f3digo seria utilizado para deixar essa tabela tidy ? 3.2. spread() spread() realiza a opera\u00e7\u00e3o inversa do gather() . Ela estica os nossos dados horizontalmente. Mas isso n\u00e3o acaba com o formato tidy do nosso banco? Sim, mas lembre-se que apenas estruturamos os nossos dados de acordo com os princ\u00edpios do tidy data porque a maior parte das fun\u00e7\u00f5es esperam esse tipo de estrutura! Isso n\u00e3o significa que ao apresentar uma tabela para algu\u00e9m ela deva estar no formato tidy . Ela simplesmente deve estar na maneira mais intuitiva de ler. tabela_long <- tibble::tribble( ~pais, ~ano, ~mortalidade, 'Brasil' , 2015 , 10.2, 'Brasil' , 2016 , 11.2, 'China' , 2015 , 14.3, 'China' , 2016 , 18.4, ) tabela_long A fun\u00e7\u00e3o spread() recebe os seguintes par\u00e2metros: (1) Primeiro, precisamos fornecer o banco de dados; (2) em segundo lugar, o nome da vari\u00e1vel cujo os valores ser\u00e3o dispostos como colunas; (3) por fim, a vari\u00e1vel que fornecer\u00e1 os valores para as c\u00e9lulas. S\u00e3o os mesmos par\u00e2metros da fun\u00e7\u00e3o gather() ! spread(<banco>, <key>, <value>) Como voc\u00ea faria para deixar o pa\u00eds na linha e os anos no cabe\u00e7alho com os valores de mortalidade ocupando o centro da tabela? Resposta : spread(tabela_long, ano, pib) 3.2.1. Aplicando no nosso banco Por favor, execute o c\u00f3digo abaixo. N\u00e3o se preocupe em entender como ele funciona. N\u00f3s veremos isso na pr\u00f3xima aula. Tenha apenas em mente que ele retorna a quantidade de observa\u00e7\u00f5es diagnosticadas com doen\u00e7a card\u00edaca entre homens e mulheres. ex3_1_1 <- banco %>% group_by(sex, target) %>% summarise(n = n()) ex3_1_1 Ser\u00e1 que essa \u00e9 a melhor maneira de visualizar esse resultado? Ainda que voc\u00ea consiga extrair alguma informa\u00e7\u00e3o, imagine se tiv\u00e9ssemos 3 ou 4 categorias em cada vari\u00e1vel. Provavelmente, n\u00e3o seria t\u00e3o f\u00e1cil. Uma maneira elegante de resolver esse problema \u00e9 com a fun\u00e7\u00e3o spread() . Como voc\u00ea aplicaria essa fun\u00e7\u00e3o para que a vari\u00e1vel target fique no cabe\u00e7alho? 4. Exerc\u00edcios - Parte 2 4.1. Exerc\u00edcio - spread() Apresente a tabela abaixo de tal maneira que as UFs fiquem nas linhas e o n\u00edvel de escolaridade esteja distribu\u00eddo pelas colunas. Item I : ex_4_1_1 <- tibble::tribble( ~UF, ~mes, ~nivel_escolaridade, 'SP', 'Jan', 20.2, 'SP', 'Fev', 29.2, 'SP', 'Mar', 12.3, 'SP', 'Abr', 14.3, 'RJ', 'Jan', 28.2, 'RJ', 'Fev', 19.2, 'RJ', 'Mar', 9.3, 'RJ', 'Abr', 30.3, ) Item II : ex_4_1_2 <- tibble::tribble( ~pais, ~ano, ~venda, 'Brasil', 2014, 20.2, 'Brasil', 2015, 29.2, 'Brasil', 2016, 12.3, 'Brasil', 2017, 14.3, 'Col\u00f4mbia', 2014, 28.2, 'Col\u00f4mbia', 2015, 19.2, 'Col\u00f4mbia', 2016, 9.3, 'Col\u00f4mbia', 2017, 30.3, ) 4.2. Exerc\u00edcio - gather() Transforme as pr\u00f3ximas tabelas em tidy data . Item I : Escolaridade: ex_4_2_1 <- tibble::tribble( ~pais, ~`Jan`, ~`Fev`, 'China', 92, 20.2, 'EUA', 10.2, 42, 'Fran\u00e7a', 72.2, 26, 'Chile', 80.2, 90, 'Jap\u00e3o', 19.1, 25, ) Item II : Mortes por arma de fogo ex_4_2_2 <- tibble::tribble( ~UF, ~`2015`, ~`2016`, 'SP', 92, 20.2, 'RJ', 10.2, 42, 'RS', 72.2, 26, 'CO', 80.2, 90, 'PE', 19.1, 25, ) 4. dplyr Dentre os pacotes mais importantes do tidyverse , o dplyr se destaca. Ele traz uma biblioteca pode rasa de fun\u00e7\u00f5es que nos permitem transformar dados. Essa \u00e9 a tarefa que voc\u00ea provavelmente passar\u00e1 mais tempo fazendo j\u00e1 que nem sempre os dados est\u00e3o limpos. Muitas vezes teremos que criar vari\u00e1veis ou extrair parte da informa\u00e7\u00e3o presente em uma antes de rodarmos um modelo. Quais s\u00e3o os verbos do dplyr ? Obviamente, o pacote \u00e9 extenso e possui uma quantidade razo\u00e1vel de fun\u00e7\u00f5es, mas queremos que voc\u00ea se atente, agora, a tr\u00eas fun\u00e7\u00f5es: select() , filter() , mutate() . 4.1. select() O select() \u00e9 capaz de selecionar colunas espec\u00edficas do nosso banco de dados. O uso dela \u00e9 bem simples e precisamos apenas escrever as vari\u00e1veis que desejamos selecionar sem aspas . Caso voc\u00ea deseje excluir uma vari\u00e1vel, acrescente um - antes do no nome. Assim como nas fun\u00e7\u00f5es do tidyr ( gather() , spread() , etc.), informamos o banco de dados no primeiro par\u00e2metro de nossa fun\u00e7\u00e3o. select(<banco>, <VAR1>, <VAR2>, -<VAR3>) Repare que antes de <VAR3> n\u00f3s adicionamos um - . Isso significa que queremos excluir essa coluna no banco Imagine que ap\u00f3s muita pesquisa, voc\u00ea tenha descoberto que a melhor vari\u00e1vel para prever doen\u00e7as card\u00edacas seja idade ( age ). Como voc\u00ea faria para selecionar apenas target e age ? Resposta : select(banco, age, target) Agora, imagine que tenha sido provado que sexo \u00e9 irrelevante. Como voc\u00ea faria para excluir essa vari\u00e1vel do banco? select(banco, -sex) 4.2. filter() Novamente, o nome da fun\u00e7\u00e3o j\u00e1 entrega o objetivo dela. filter() filtra (d\u00e3\u00e3) as observa\u00e7\u00f5es da nossa tabela por meio de opera\u00e7\u00f5es booleanas . Operadores l\u00f3gicos N\u00f3s vimos na primeira aula que operadores l\u00f3gicas s\u00e3o opera\u00e7\u00f5es que retornam necessariamente apenas dois resultados: verdadeiro e falso. A partir de agora, come\u00e7aremos a utilizar eles cada vez mais. Ent\u00e3o, se n\u00e3o estiver se sentindo confort\u00e1vel com o tema, volte para a primeira aula e reveja os exemplos. Como ela funciona? Simples, voc\u00ea apenas precisa realizar um teste de verdadeiro e falso a partir de uma vari\u00e1vel do seu banco. filter(<banco>, <operacao_booleana>) Repare no banco abaixo. Como voc\u00ea faria para selecionar as observa\u00e7\u00f5es de SP ? exemplo_filter <- tibble::tribble( ~UF, ~`2015`, ~`2016`, 'SP', 92, 20.2, 'RJ', 10.2, 42, 'RS', 72.2, 26, 'CO', 80.2, 90, 'PE', 19.1, 25, ) exemplo_filter Qual o operador l\u00f3gico que testa igualdade? Se voc\u00ea pensou no == , acertou! :tada: Agora, s\u00f3 precisamos coloc\u00e1-lo dentro do filter() e deixar que m\u00e1gica aconte\u00e7a. Resposta : filter(exemplo_filter, UF == 'SP') 4.3. mutate() mutate() nos permite transformar e criar colunas em nossa tabela de maneira r\u00e1pida e intuitiva. Repare na tabela abaixo. exemplo_mutate <- tibble::tribble( ~UF, ~mes, ~total, ~homi 'SP', 'Jan', 20.2, 3 'SP', 'Fev', 29.2, 4 'SP', 'Mar', 12.3, 6 'SP', 'Abr', 14.3, 4 'RJ', 'Jan', 28.2, 3 'RJ', 'Fev', 19.2, 3 'RJ', 'Mar', 9.3, 10 'RJ', 'Abr', 30.3, 20 ) Sento total o total de mortes registradas naquele m\u00eas e homi valor absoluto de homic\u00eddios, \u00e9 poss\u00edvel retirar a taxa de homic\u00eddios entre todas as outras mortes realizando com a opera\u00e7\u00e3o de divis\u00e3o. mutate(<banco>, <variavel> = <operacao>) Novamente, o banco de dados \u00e9 fornecido como primeiro par\u00e2metro. A diferen\u00e7a \u00e9 que dessa vez iremos fazer refer\u00eancias a vari\u00e1veis ( <variavel> ) dentro da fun\u00e7\u00e3o mutate() para alter\u00e1-las. Em <operacoes> , voc\u00ea pode fazer refer\u00eancia a outras vari\u00e1veis do banco ou at\u00e9 mesmo de outros objetos para realizar a sua conta. Voc\u00ea consegue imaginar como escrever o c\u00f3digo acima para retirar a taxa de homic\u00eddios?","title":"Estruturar"},{"location":"02_estruturar/#1-tidyr","text":"O tidyr \u00e9 o pacote utilizado para estruturar os nossos bancos de dados. Em geral, ele pode ser utilizado para unir ( unite ) e separar ( separate ) colunas ou para derreter ( gather ) e esticar ( spread ) as colunas. Esse pacote \u00e9 constru\u00eddo com base no conceito de tidy data . Deixar os seus dados tidy significa transformar a estrutura deles de tal maneira que tenhamos observa\u00e7\u00f5es nas linhas, vari\u00e1veis nas colunas e valores nas c\u00e9lulas. Em geral, esperamos tamb\u00e9m que um banco tidy contenha apenas uma unidade de observa\u00e7\u00e3o, granularidade, etc. Ilustra\u00e7\u00e3o do Tidy Data (Fonte: http://statseducation.com ) O que \u00e9 unidade de observa\u00e7\u00e3o / granularidade? Trata-se da unidade contida nas linhas do seu banco. Por exemplo, se montarmos um banco de dados com informa\u00e7\u00f5es sobre pessoas (altura, idade, peso, etc.) em cada linha teremos pessoas como unidade de observa\u00e7\u00e3o. Qual a unidade de observa\u00e7\u00e3o do nosso banco?","title":"1. tidyr"},{"location":"02_estruturar/#11-separate","text":"Instalando pacotes Caso voc\u00ea n\u00e3o tenha o tidyr ou o tibble no seu computador, por favor, execute o c\u00f3digo install.packages(c('tidyr', 'tibble')) . separate() \u00e9 uma fun\u00e7\u00e3o do pacote tidyr que tem como objetivo separar valores contidos em uma coluna. \u00c0s vezes, mais de uma informa\u00e7\u00e3o \u00e9 agrupado dentro da mesma vari\u00e1vel. Repare no exemplo abaixo. exemplo_separete <- tibble::tribble( ~ CIDADE , ~MORTALIDADE, 'S\u00e3o Jos\u00e9 dos Campos - SP', 80, 'Porto Alegre - RS', 100, 'Bras\u00edlia - DF', 81 ) exemplo_separete Qual vari\u00e1vel cont\u00e9m mais de uma informa\u00e7\u00e3o? Por mais que talvez voc\u00ea tenha o costume de agrupar a sua cidade \u00e0 unidade federativa dela, esses dois valores dizem respeito a qualidades diferentes da nossa oberva\u00e7\u00e3o. Imagine que o banco se estendesse para todas as cidades brasileiras. Como far\u00edamos para identificar as unidades federativas com maior m\u00e9dia de mortalidade? Como aplicar a fun\u00e7\u00e3o separate() ? Antes de tudo, tente executar o comando ?separate . A documenta\u00e7\u00e3o do tidyr tende a ser muito boa e normalmente teremos uma boa explica\u00e7\u00e3o de como a fun\u00e7\u00e3o opera e de quais par\u00e2metros precisamos utilizar nela. No caso, o separate() recebe (1) no primeiro par\u00e2metro o banco de dados, (2) no segundo, a coluna que desejamos separar, (3) na terceira o nome das colunas que desejamos criar a partir da coluna informada no segundo par\u00e2metro, (4) o separador, ou seja, o padr\u00e3o de caracteres que ser\u00e3o utilizados para separar a coluna do segundo par\u00e2metro nas colunas especificadas no terceiro par\u00e2metro. Isso pode parecer complicado, mas \u00e9 bem simples. separate(<dataframe>, <coluna_que_desejamos_separar>, <vetor_com_as_colunas_a_serem_criadas>, <separador>) Tente fazer sozinho. Reposta : separate(exemplo_separete, 'CIDADE', c('CIDADE', 'UF'), '-')","title":"1.1 separate()"},{"location":"02_estruturar/#111-aplicando-no-nosso-banco","text":"Voc\u00ea consegue descobrir qual vari\u00e1vel no nosso banco tem esse problema? Fun\u00e7\u00f5es para explorar dataframes Tente utilizar fun\u00e7\u00f5es para explorar o seu dataframe. Por exemplo, com head() conseguimos obter facilmente as primeiras linhas do nosso banco. Voc\u00ea percebeu alguma coisa de estranho na vari\u00e1vel age_sex ? O que? age_sex cont\u00e9m dois tipos de informa\u00e7\u00f5es diferentes. De um lado, temos a idade da pessoa. Do outro, temos o sexo dessa pessoa. Novamente, precisamos separar essas duas informa\u00e7\u00f5es em duas vari\u00e1veis para que possamos prosseguir com a nossa an\u00e1lise. Vamos l\u00e1? Agora \u00e9 a sua vez. Como precisamos fazer para separar as duas vari\u00e1veis? \ud83d\udcaa PS: N\u00e3o se preocupe com o remove = FALSE . Utilizamos esse par\u00e2metro apenas para manter a vari\u00e1vel antiga e sermos capazes de validar o nosso resultado. separate(<banco>, <variavel>, <vetor>, <sep>, remove = FALSE) Que tal dar um View() no seu banco agora? View(banco) Salvando altera\u00e7\u00f5es Nunca se esque\u00e7a de que o R n\u00e3o sabe que voc\u00ea deseja sobrescrever uma vari\u00e1vel. Ao contr\u00e1rio do Stata, por exemplo, as altera\u00e7\u00f5es devem ser escritas sobre uma vari\u00e1vel com <- . Caso contr\u00e1rio, o R ir\u00e1 apenas imprimir no console o resultado. Agora, podemos utilizar o View() ou o head() para verificar se deu tudo certo.","title":"1.1.1. Aplicando no nosso banco"},{"location":"02_estruturar/#12-unite","text":"A fun\u00e7\u00e3o unite() tem o comportamento inverso separate() . N\u00f3s a utilizamos para unir valores que fazem mais sentido juntos do que separados. Repare no exemplo abaixo. O que voc\u00ea faria para obter em uma \u00fanica vari\u00e1vel uma informa\u00e7\u00e3o mais precisa? exemplo_unite <- tibble::tribble( ~ID,~DIA, ~MES, ~ANO, ~DOSE_REMEDIO, ~RESULTADO, 1, 14, 8, 2018, 1, 0, 1, 15, 8, 2018, 2, 0, 2, 9, 7, 2018, 1 ,0, 2, 10, 7, 2018, 2, 0, 2, 11, 7, 2018, 3, 1 ) exemplo_unite Ap\u00f3s executar o c\u00f3digo acima, vamos prosseguir com a fun\u00e7\u00e3o unite() . Ela recebe (1) no primeiro par\u00e2metro o banco de dados e (2) no segundo o nome da nova vari\u00e1vel. Em seguida, (3) adicionamos todas as colunas que queremos concatenar (4) e, por fim, podemos escolher o separador entre as colunas. unite(<banco>, <nome_da_nova_variavel>, sep = '<separador>') Vamos tentar sozinho primeiro? Resposta : banco <- unite(exemplo_unite, \"DATA\", ANO, MES, DIA, sep = \"-\") Verifique o resultado com a fun\u00e7\u00e3o head() .","title":"1.2. unite"},{"location":"02_estruturar/#121-aplicando-no-nosso-banco","text":"Que tal arrumar, agora, o nosso banco de dados tamb\u00e9m? Lembre-se que \u00e9 poss\u00edvel utilizar a as fun\u00e7\u00f5es head() , str() , entre outras para ter uma ideia geral da estrutura do nosso dataframe . Provavelmente, voc\u00ea reparou que existem tr\u00eas vari\u00e1veis que, na verdade, fornam uma \u00fanica: birth_day , birth_month e birth_year . Que tal tentar uni-las com a fun\u00e7\u00e3o separate() ?","title":"1.2.1. Aplicando no nosso banco"},{"location":"02_estruturar/#2-exercicios-parte-1","text":"N\u00f3s acabamos de aprender a estruturar o nosso banco no que diz respeito a unir e separar vari\u00e1veis. Vamos praticar mais um pouco?","title":"2. Exerc\u00edcios - Parte 1"},{"location":"02_estruturar/#21-exercicio-exemplos-de-unite-e-separate","text":"Para cada tabela abaixo (1) diga se \u00e9 necess\u00e1rio realizar um unite() ou um separate() e (2) escreva o c\u00f3digo que corrija esse problema. Item I : ex2_1_1 <- tibble::tribble( ~ANO, ~RAZAO_DE_HOMICIDIO, 2014, '1200293 / 102000000', 2015, '201992 / 102929222', 2016, '203918 / 175999271', 2017, '2901827 / 228191900', 2018, '201928 / 201928238', ) Item II : ex_2_1_2 <- tibble::tribble( ~NOME, ~LOGRADOUR, ~NUMERO, ~COMPLEMENTO, 'Lyandra', 'Rua Ademar de Barros', 20, 'APT 28', 'Monica', 'Avenida S\u00e3o Pedro', 30, 'BLOCO A', 'Luis', 'Rua do Lago', 22, 'Port\u00e3o do lado esquerdo', 'Isaac', 'Avenida Paulista', 22, 'APT 102', 'S\u00f4nia', 'Rua Brigadeiro', 982, 'APT 283' ) Item III : ex_2_1_3 <- tibble::tribble( ~ID, ~DIA, ~MES, ~ANO, ~ALTURA_PESO, 1, 10, 2, 1998, '180 - 340', 2, 11, 2, 1998, '190 - 200', 3, 20, 3, 1998, '188 - 176', 2, 30, 5, 1998, '192 - 180' ) Parab\u00e9ns! :tada: :tada: :tada:","title":"2.1. Exerc\u00edcio - Exemplos de unite e separate"},{"location":"02_estruturar/#3-gather-e-spread","text":"Voc\u00ea j\u00e1 ouviu falar em bancos no formato wide e long ? Mortalidade na China e no Brasil - Wide Pa\u00eds 2015 2016 Brasil 12 12.2 China 20 30 Mortalidade na China e no Brasil - Long Pa\u00eds Ano Mortalidade Brasil 2015 12 Brasil 2016 12.2 China 2015 20 China 2016 30 Qual a diferen\u00e7a entre os dois bancos? Quais deles est\u00e1 no formato tidy ? Se poss\u00edvel escreva ou tente explicar em voz alta. Como o primeiro banco n\u00e3o cont\u00e9m apenas uma oberva\u00e7\u00e3o por linha, ele n\u00e3o \u00e9 tidy . Voc\u00ea concorda que as tomadas de dados sobre mortalidade sobre dois anos n\u00e3o podem ocorrer simultaneamente no mesmo ano? Al\u00e9m disso, 2015 e 2016 est\u00e3o ocupando a posi\u00e7\u00e3o de vari\u00e1veis, mas elas na verdade s\u00e3o valores de uma outra vari\u00e1vel? Voc\u00ea sabe dizer qual? O exemplo de banco tidy \u00e9 o segundo. Nele, temos as vari\u00e1veis claramente denominadas no cabe\u00e7alho do nosso banco. Pa\u00eds \u00e9 uma vari\u00e1vel, assim como Ano e Mortalidade . E cada linha possui uma \u00fanica observa\u00e7\u00e3o. Que fique bem claro: tidy n\u00e3o \u00e9 uma defini\u00e7\u00e3o de qualidade do banco. Apenas tentamos estruturar a nossa tabela nesse formato porque isso torna mais f\u00e1cil a intera\u00e7\u00e3o com outras fun\u00e7\u00f5es (ex. dplyr , ggplot , etc.).","title":"3. Gather e Spread"},{"location":"02_estruturar/#31-gather","text":"gather() \u00e9 utilizado para derreter/agrupar as colunas dos nossos bancos. Pensando no exemplo anterior, essa fun\u00e7\u00e3o transforma o nosso banco wide em um banco long . tabela_wide <- tibble::tribble( ~Pa\u00eds , ~`2015`, ~`2016`, 'Brasil' , 10.2 , 11.2, 'China' , 14.3 , 18.4, ) tabela_wide gather() recebe (1) o banco de dados, (2) o nome da vari\u00e1vel ( key ) que est\u00e1 como nome das colunas, (3) o nome da vari\u00e1vel que est\u00e1 nas c\u00e9lulas, (4) os nomes das colunas em que iremos realizar a opera\u00e7\u00e3o sem aspas . gather(<banco>, <key>, <value>, <VAR1>, <VAR2>, <VARn>) Dado isso, qual c\u00f3digo devemos utilizar para realizar a transforma\u00e7\u00e3o em tabela_wide . Resposta : gather(tabela_wide, key = 'ano', value = 'mortalidade' ,`2015`, `2016`)","title":"3.1. gather()"},{"location":"02_estruturar/#311-aplicando","text":"Como o nosso banco n\u00e3o possui esse problema, vamos fingir que decidimos realizar uma segunda coleta de dados e queremos avaliar a evolu\u00e7\u00e3o de doen\u00e7as card\u00edacas nossos pacientes ap\u00f3s 1 ano. Por\u00e9m, o seu estagi\u00e1rio era pregui\u00e7oso e ao inv\u00e9s de estruturar o seu banco no formato tidy ele (1) alterou o nome da coluna target para target2018 e (2) criou uma coluna target2019 para os novos resultados ex3_1_1 <- tibble::tribble( ~ID, ~target2018, ~target2019, 1, 0, 0, 2, 1, 1, 3, 1, 1, 4, 1, 1, 5, 1, 0, ) ex3_1_1 Qual c\u00f3digo seria utilizado para deixar essa tabela tidy ?","title":"3.1.1. Aplicando"},{"location":"02_estruturar/#32-spread","text":"spread() realiza a opera\u00e7\u00e3o inversa do gather() . Ela estica os nossos dados horizontalmente. Mas isso n\u00e3o acaba com o formato tidy do nosso banco? Sim, mas lembre-se que apenas estruturamos os nossos dados de acordo com os princ\u00edpios do tidy data porque a maior parte das fun\u00e7\u00f5es esperam esse tipo de estrutura! Isso n\u00e3o significa que ao apresentar uma tabela para algu\u00e9m ela deva estar no formato tidy . Ela simplesmente deve estar na maneira mais intuitiva de ler. tabela_long <- tibble::tribble( ~pais, ~ano, ~mortalidade, 'Brasil' , 2015 , 10.2, 'Brasil' , 2016 , 11.2, 'China' , 2015 , 14.3, 'China' , 2016 , 18.4, ) tabela_long A fun\u00e7\u00e3o spread() recebe os seguintes par\u00e2metros: (1) Primeiro, precisamos fornecer o banco de dados; (2) em segundo lugar, o nome da vari\u00e1vel cujo os valores ser\u00e3o dispostos como colunas; (3) por fim, a vari\u00e1vel que fornecer\u00e1 os valores para as c\u00e9lulas. S\u00e3o os mesmos par\u00e2metros da fun\u00e7\u00e3o gather() ! spread(<banco>, <key>, <value>) Como voc\u00ea faria para deixar o pa\u00eds na linha e os anos no cabe\u00e7alho com os valores de mortalidade ocupando o centro da tabela? Resposta : spread(tabela_long, ano, pib)","title":"3.2. spread()"},{"location":"02_estruturar/#321-aplicando-no-nosso-banco","text":"Por favor, execute o c\u00f3digo abaixo. N\u00e3o se preocupe em entender como ele funciona. N\u00f3s veremos isso na pr\u00f3xima aula. Tenha apenas em mente que ele retorna a quantidade de observa\u00e7\u00f5es diagnosticadas com doen\u00e7a card\u00edaca entre homens e mulheres. ex3_1_1 <- banco %>% group_by(sex, target) %>% summarise(n = n()) ex3_1_1 Ser\u00e1 que essa \u00e9 a melhor maneira de visualizar esse resultado? Ainda que voc\u00ea consiga extrair alguma informa\u00e7\u00e3o, imagine se tiv\u00e9ssemos 3 ou 4 categorias em cada vari\u00e1vel. Provavelmente, n\u00e3o seria t\u00e3o f\u00e1cil. Uma maneira elegante de resolver esse problema \u00e9 com a fun\u00e7\u00e3o spread() . Como voc\u00ea aplicaria essa fun\u00e7\u00e3o para que a vari\u00e1vel target fique no cabe\u00e7alho?","title":"3.2.1. Aplicando no nosso banco"},{"location":"02_estruturar/#4-exercicios-parte-2","text":"","title":"4. Exerc\u00edcios - Parte 2"},{"location":"02_estruturar/#41-exercicio-spread","text":"Apresente a tabela abaixo de tal maneira que as UFs fiquem nas linhas e o n\u00edvel de escolaridade esteja distribu\u00eddo pelas colunas. Item I : ex_4_1_1 <- tibble::tribble( ~UF, ~mes, ~nivel_escolaridade, 'SP', 'Jan', 20.2, 'SP', 'Fev', 29.2, 'SP', 'Mar', 12.3, 'SP', 'Abr', 14.3, 'RJ', 'Jan', 28.2, 'RJ', 'Fev', 19.2, 'RJ', 'Mar', 9.3, 'RJ', 'Abr', 30.3, ) Item II : ex_4_1_2 <- tibble::tribble( ~pais, ~ano, ~venda, 'Brasil', 2014, 20.2, 'Brasil', 2015, 29.2, 'Brasil', 2016, 12.3, 'Brasil', 2017, 14.3, 'Col\u00f4mbia', 2014, 28.2, 'Col\u00f4mbia', 2015, 19.2, 'Col\u00f4mbia', 2016, 9.3, 'Col\u00f4mbia', 2017, 30.3, )","title":"4.1. Exerc\u00edcio - spread()"},{"location":"02_estruturar/#42-exercicio-gather","text":"Transforme as pr\u00f3ximas tabelas em tidy data . Item I : Escolaridade: ex_4_2_1 <- tibble::tribble( ~pais, ~`Jan`, ~`Fev`, 'China', 92, 20.2, 'EUA', 10.2, 42, 'Fran\u00e7a', 72.2, 26, 'Chile', 80.2, 90, 'Jap\u00e3o', 19.1, 25, ) Item II : Mortes por arma de fogo ex_4_2_2 <- tibble::tribble( ~UF, ~`2015`, ~`2016`, 'SP', 92, 20.2, 'RJ', 10.2, 42, 'RS', 72.2, 26, 'CO', 80.2, 90, 'PE', 19.1, 25, )","title":"4.2. Exerc\u00edcio - gather()"},{"location":"02_estruturar/#4-dplyr","text":"Dentre os pacotes mais importantes do tidyverse , o dplyr se destaca. Ele traz uma biblioteca pode rasa de fun\u00e7\u00f5es que nos permitem transformar dados. Essa \u00e9 a tarefa que voc\u00ea provavelmente passar\u00e1 mais tempo fazendo j\u00e1 que nem sempre os dados est\u00e3o limpos. Muitas vezes teremos que criar vari\u00e1veis ou extrair parte da informa\u00e7\u00e3o presente em uma antes de rodarmos um modelo. Quais s\u00e3o os verbos do dplyr ? Obviamente, o pacote \u00e9 extenso e possui uma quantidade razo\u00e1vel de fun\u00e7\u00f5es, mas queremos que voc\u00ea se atente, agora, a tr\u00eas fun\u00e7\u00f5es: select() , filter() , mutate() .","title":"4. dplyr"},{"location":"02_estruturar/#41-select","text":"O select() \u00e9 capaz de selecionar colunas espec\u00edficas do nosso banco de dados. O uso dela \u00e9 bem simples e precisamos apenas escrever as vari\u00e1veis que desejamos selecionar sem aspas . Caso voc\u00ea deseje excluir uma vari\u00e1vel, acrescente um - antes do no nome. Assim como nas fun\u00e7\u00f5es do tidyr ( gather() , spread() , etc.), informamos o banco de dados no primeiro par\u00e2metro de nossa fun\u00e7\u00e3o. select(<banco>, <VAR1>, <VAR2>, -<VAR3>) Repare que antes de <VAR3> n\u00f3s adicionamos um - . Isso significa que queremos excluir essa coluna no banco Imagine que ap\u00f3s muita pesquisa, voc\u00ea tenha descoberto que a melhor vari\u00e1vel para prever doen\u00e7as card\u00edacas seja idade ( age ). Como voc\u00ea faria para selecionar apenas target e age ? Resposta : select(banco, age, target) Agora, imagine que tenha sido provado que sexo \u00e9 irrelevante. Como voc\u00ea faria para excluir essa vari\u00e1vel do banco? select(banco, -sex)","title":"4.1. select()"},{"location":"02_estruturar/#42-filter","text":"Novamente, o nome da fun\u00e7\u00e3o j\u00e1 entrega o objetivo dela. filter() filtra (d\u00e3\u00e3) as observa\u00e7\u00f5es da nossa tabela por meio de opera\u00e7\u00f5es booleanas . Operadores l\u00f3gicos N\u00f3s vimos na primeira aula que operadores l\u00f3gicas s\u00e3o opera\u00e7\u00f5es que retornam necessariamente apenas dois resultados: verdadeiro e falso. A partir de agora, come\u00e7aremos a utilizar eles cada vez mais. Ent\u00e3o, se n\u00e3o estiver se sentindo confort\u00e1vel com o tema, volte para a primeira aula e reveja os exemplos. Como ela funciona? Simples, voc\u00ea apenas precisa realizar um teste de verdadeiro e falso a partir de uma vari\u00e1vel do seu banco. filter(<banco>, <operacao_booleana>) Repare no banco abaixo. Como voc\u00ea faria para selecionar as observa\u00e7\u00f5es de SP ? exemplo_filter <- tibble::tribble( ~UF, ~`2015`, ~`2016`, 'SP', 92, 20.2, 'RJ', 10.2, 42, 'RS', 72.2, 26, 'CO', 80.2, 90, 'PE', 19.1, 25, ) exemplo_filter Qual o operador l\u00f3gico que testa igualdade? Se voc\u00ea pensou no == , acertou! :tada: Agora, s\u00f3 precisamos coloc\u00e1-lo dentro do filter() e deixar que m\u00e1gica aconte\u00e7a. Resposta : filter(exemplo_filter, UF == 'SP')","title":"4.2. filter()"},{"location":"02_estruturar/#43-mutate","text":"mutate() nos permite transformar e criar colunas em nossa tabela de maneira r\u00e1pida e intuitiva. Repare na tabela abaixo. exemplo_mutate <- tibble::tribble( ~UF, ~mes, ~total, ~homi 'SP', 'Jan', 20.2, 3 'SP', 'Fev', 29.2, 4 'SP', 'Mar', 12.3, 6 'SP', 'Abr', 14.3, 4 'RJ', 'Jan', 28.2, 3 'RJ', 'Fev', 19.2, 3 'RJ', 'Mar', 9.3, 10 'RJ', 'Abr', 30.3, 20 ) Sento total o total de mortes registradas naquele m\u00eas e homi valor absoluto de homic\u00eddios, \u00e9 poss\u00edvel retirar a taxa de homic\u00eddios entre todas as outras mortes realizando com a opera\u00e7\u00e3o de divis\u00e3o. mutate(<banco>, <variavel> = <operacao>) Novamente, o banco de dados \u00e9 fornecido como primeiro par\u00e2metro. A diferen\u00e7a \u00e9 que dessa vez iremos fazer refer\u00eancias a vari\u00e1veis ( <variavel> ) dentro da fun\u00e7\u00e3o mutate() para alter\u00e1-las. Em <operacoes> , voc\u00ea pode fazer refer\u00eancia a outras vari\u00e1veis do banco ou at\u00e9 mesmo de outros objetos para realizar a sua conta. Voc\u00ea consegue imaginar como escrever o c\u00f3digo acima para retirar a taxa de homic\u00eddios?","title":"4.3. mutate()"},{"location":"03_transformar/","text":"Transformando Dados Aviso importante! Antes de come\u00e7ar a programar, atualize o R e seus pacotes rodando os seguintes comandos: install.packages(\"installr\") updateR() Siga as instru\u00e7\u00f5es e em caso de d\u00favidas procure um monitor. Lembre-se de instalar o tidyverse novamente. Aten\u00e7\u00e3o! Se liga a\u00ed que \u00e9 hora da revis\u00e3o (e dicas)! Scripts Scripts nada mais s\u00e3o do que uma s\u00e9rie de comandos salvos em um arquivo. Eles s\u00e3o \u00fateis para mantermos a reprodutividade do c\u00f3digo, portanto, sempre que formos utilizar o RStudio \u00e9 recomendado escrever um script. Vetores Estrutura b\u00e1sica de dados Homog\u00eaneo: aceita apenas um tipo de dado Indexa\u00e7\u00e3o por colchetes simples Apenas 1 n\u00edvel Listas Estrutura de dados Heterog\u00eaneo: aceita mais de um tipo de dado Indexa\u00e7\u00e3o por colchetes duplo M\u00faltiplos n\u00edveis Fun\u00e7\u00f5es O R base, como chamamos o R sem nenhum pacote instalado por n\u00f3s, j\u00e1 cont\u00e9m diversas fun\u00e7\u00f5es implementadas para realizar a\u00e7\u00f5es sobre os dados que temos a disposi\u00e7\u00e3o. Geralmente, o nome das fun\u00e7\u00f5es j\u00e1 nos d\u00e3o uma no\u00e7\u00e3o de suas a\u00e7\u00f5es. Por exemplo, a fun\u00e7\u00e3o mean() , do portugu\u00eas m\u00e9dia, aplica justamente a m\u00e9dia sobre os dados informados. Para informar os dados e tamb\u00e9m definir alguns dos comportamentos dessa a\u00e7\u00e3o, usamos o par\u00e2metros, que ficam dentro dos par\u00eanteses de cada fun\u00e7\u00e3o. Exerc\u00edcios de revis\u00e3o Para praticarmos algumas coisas que vimos at\u00e9 agora tente fazer os seguintes exerc\u00edcios: Baixe este arquivo e importe-o para seu projeto do RStudio. Calcula a m\u00e9dia de colesterol e armazene-a em um objeto chamado med_colesterol. Verifique se os valores de colesterol de cada observa\u00e7\u00e3o s\u00e3o maiores do que a m\u00e9dia. Separe a coluna age_sex, criando as colunas age e sex com seus respectivos valores. dplyr e suas fun\u00e7\u00f5es Para tornar a manipula\u00e7\u00e3o de dados mais eficiente, foi criado um pacote chamado de dplyr que possui uma s\u00e9rie de ferramentas para filtrar, selecionar e sumarizar informa\u00e7\u00f5es, como veremos a seguir. Fun\u00e7\u00f5es As principais fun\u00e7\u00f5es do dplyr s\u00e3o: filter : filtra as linhas de um banco de dados de acordo com uma regra l\u00f3gica. select : seleciona as colunas de interesse. mutate : modifica ou cria colunas de acordo com valores fornecidos. count : conta os valores de uma vari\u00e1vel. Especialmente \u00fatil para vari\u00e1veis categ\u00f3ricas. rename : altera o nome das vari\u00e1veis (colunas). group_by e summarise : s\u00e3o fun\u00e7\u00f5es normalmente utilizadas em conjunto. Elas permitem realizar opera\u00e7\u00f5es de agrega\u00e7\u00f5es com o banco de dados e, assim, alterar a nossa unidade de an\u00e1lise. Por\u00e9m, n\u00e3o ficaremos apenas nestas fun\u00e7\u00f5es, veremos tamb\u00e9m algumas de suas varia\u00e7\u00f5es e conheceremos o famoso %>% (pipe). Para as atividades abaixo vamos usar o mesmo banco utilizado nos exerc\u00edcios. Como vimos, o dplyr \u00e9 um pacote essencial para manipula\u00e7\u00e3o de dados e uma das suas vantagens \u00e9 que a forma como aplicamos suas fun\u00e7\u00f5es segue o seguinte padr\u00e3o: funcao_dplyr(banco_de_dados, argumentos_especificos) Ou seja, o primeiro argumento de qualquer uma das fun\u00e7\u00f5es \u00e9 o banco de dados, seguido de argumentos espec\u00edficos de cada fun\u00e7\u00e3o, como por exemplo, qual vari\u00e1vel criar ou filtrar. filter() Quando estamos fazendo algumas an\u00e1lises, \u00e9 comum encontrarmos observa\u00e7\u00f5es que n\u00e3o nos interessam, como por exemplo, se estou fazendo uma an\u00e1lise sobre pessoas com a\u00e7\u00facar no sangue em jejum menor ou igual do que 120mg/dl, espero que na minha base de dados tenham apenas pessoas que atendam essa condi\u00e7\u00e3o. Para isso utilizamos o filter() , vejamos o exemplo abaixo: filter(dados, fbs == 0) Lembra quando vimos operadores l\u00f3gicos? Pois bem, eles s\u00e3o muito utilizados no filter() . Caso o nosso interesse seja n\u00e3o apenas filtrar sobre a taxa de a\u00e7ucar , mas pessoas do sexo masculino adicionamos o nome da vari\u00e1vel, seguido do condicional filter(dados, fbs == 0, sex == \"Homem\") E se al\u00e9m dos filtros propostos tamb\u00e9m quisermos separar os candidatos com Tipo de dor no peito igual a 1 e 4? Para fazer esse filtro podemos utilizar o operador %in% ! Ele basicamente nos ajuda a filtrar mais de um tipo de categoria de uma vari\u00e1vel, uma vez que o operador == compara apenas uma categoria. filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4)) # perceba a importancia de colocar as categorias que serao filtradas dentro de um vetor Vamos aproveitar para filtrar os casos em que os pacientes n\u00e3o tiveram angina induzida por exerc\u00edcio e guardar esse dado em um objeto chamado amostra1 . amostra1 <- filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1) Agora temos uma outra base de dados para analisarmos. Vamos conhecer ent\u00e3o o select() . select() Em muitas situa\u00e7\u00f5es n\u00f3s n\u00e3o trabalhamos com todas as vari\u00e1veis do banco de dados; para removermos aquelas colunas que n\u00e3o iremos utilizar, adotamos a fun\u00e7\u00e3o select() . Vamos selecionar apenas a idade e a press\u00e3o sangu\u00ednea. select(amostra1, age, trestbps) Percebeu o padr\u00e3o dessa fun\u00e7\u00e3o? Basicamente \u00e9 o banco de dados e as vari\u00e1veis que queremos selecionar. Mas e se quisermos visualizar todas as vari\u00e1veis com exce\u00e7\u00e3o de algumas? select(amostra1, -target, -restecg) No exemplo acima estamos retirando as vari\u00e1veis target e restecg colocando um - na frente dessas vari\u00e1veis. Para darmos continuidade \u00e0s outras fun\u00e7\u00f5es vamos retirar algumas vari\u00e1veis amostra1 <- select(amostra1, -slope, -ca, -thal) mutate() Caso tenhamos interesse em alterar ou criar uma vari\u00e1vel, podemos utilizar o mutate() . A fun\u00e7\u00e3o tem o seguinte formato: mutate(bando_de_dados, coluna_nova|coluna_existente = valor) . Vamos aproveitar e alterar a vari\u00e1vel de idade age para n\u00famerico amostra1 <- mutate(amostra1, age = as.numeric(age)) amostra1 Simples n\u00e3o? Al\u00e9m disso, podemos criar vari\u00e1veis categ\u00f3ricas, como por exemplo, uma vari\u00e1vel que identifica se a pessoa tem uma idade maior ou menor de 60 anos. amostra1 <- mutate(amostra1, CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")) amostra1 Perceba que para criar essa vari\u00e1vel utilizamos uma fun\u00e7\u00e3o chamada ifelse() . Basicamente esta fun\u00e7\u00e3o \u00e9 um if em que o primeiro par\u00e2metro \u00e9 a condi\u00e7\u00e3o l\u00f3gica, o segundo \u00e9 a a\u00e7\u00e3o em caso de a condi\u00e7\u00e3o ser verdadeira e o terceiro \u00e9 a a\u00e7\u00e3o no caso de a condi\u00e7\u00e3o ser falsa. Assim, no caso acima ele pergunta: Se o valor da vari\u00e1vel age for menor \u00e0 60, classificamos como \u201cADULTO\u201d, caso negativo, \u201cIDOSO\u201d. Agora que criamos a vari\u00e1vel \u201cCATEGORIA_IDADE\u201d, quantas pessoas s\u00e3o idosas neste experimento? Para respondermos isso podemos utilizar a fun\u00e7\u00e3o count() count() Em uma tradu\u00e7\u00e3o literal, o count() ir\u00e1 contar as categorias de uma vari\u00e1vel. tabela_cat_idade <- count(amostra1, CATEGORIA_IDADE) tabela_cat_idade Portanto, podemos notar que existem mais adultos em nossa amostra. rename() Se quisermos renomear o nome das vari\u00e1veis temos que utilizar o rename() que tem o seguinte padr\u00e3o: rename(bando_de_dados, nome_novo = nome_antigo) tabela_cat_idade <- rename(tabela_cat_idade, Quantidade = n) tabela_cat_idade group_by() e summarise() O group_by() e summarise() s\u00e3o fun\u00e7\u00f5es que trabalham, na maioria das vezes, juntas. Eles servem para sumarizar os dados de acordo com grupos, ou seja, a contagem que haviamos feito com o count() pode ser reproduzida aqui da seguinte forma: temp_1 <- group_by(amostra1, CATEGORIA_IDADE) temp_1 summarise(temp_1, Quantidade = n()) O objeto temp_1 \u00e9 uma tabela agrupada! Visualmente ela parece normal, por\u00e9m qualquer opera\u00e7\u00e3o feita nela ser\u00e1 realizada de acordo com os grupos nos quais ela encontrou, que neste caso \u00e9: ADULTO e IDOSO. Quando utilizamos o summarise, iremos agrupar as categorias em torno de uma estat\u00edstica, no caso, a contagem. Para fazer isso, utilizamos a fun\u00e7\u00e3o n() , uma fun\u00e7\u00e3o utilizada para contar oberva\u00e7\u00f5es. Caso a vari\u00e1vel que fossemos sumarizar fosse n\u00famerica, poderiamos utilizar a m\u00e9dia ( mean() ), mediana ( median() ) e assim por diante. Portanto, a vantagem do group_by() e summarise() \u00e9 que conseguimos sumarizar com outras estat\u00edsticas al\u00e9m da contagem. Vejamos o exemplo abaixo. Estamos agrupando pela categoria de idade e sexo do indiv\u00edduo. Ap\u00f3s isto, estamos contando o n\u00famero de observa\u00e7\u00f5es que apresentam estas categorias. temp_2 <- group_by(dados, CATEGORIA_IDADE, sex) summarise(temp_2, Quantidade = n()) Com isso podemos verificar que houveram maior participa\u00e7\u00e3o de adultos na amostra. %>% At\u00e9 ent\u00e3o, vimos as principais fun\u00e7\u00f5es do dplyr . Conseguimos extrair uma amostra com caracter\u00edsticas espec\u00edficas e esbo\u00e7ar algumas conclus\u00f5es sua variabilidade. Tamb\u00e9m poder\u00edamos fazer igual ao c\u00f3digo abaixo, por\u00e9m a interpreta\u00e7\u00e3o desse c\u00f3digo se torna mais complexa, uma vez que as a\u00e7\u00f5es s\u00e3o realizadas de dentro pra fora. rename(count(mutate(select(filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1), -slope, -ca, -thal), age = as.numeric(age), CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")), CATEGORIA_IDADE), Quantidade = n) Para solucionar este problema os desenvolvedores do pacote incluiram um operador chamado de pipe ( %>% ). Basicamente ele permite que possamos contruir c\u00f3digos de forma linear, como podemos notar abaixo! dados %>% filter(fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1) %>% select(-slope, -ca, -thal) %>% mutate(age = as.numeric(age), CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")) %>% count(CATEGORIA_IDADE) %>% rename(Quantidade = n) Agora podemos interpretar o c\u00f3digo acima da seguinte maneira: Pegamos a nossa base de dados sobre doen\u00e7as card\u00edacas com o nome \u201cdados\u201d, aplicamos um FILTER para filtrar as observa\u00e7\u00f5es do banco, em seguida o SELECT para removermos colunas que n\u00e3o queremos. Depois alteramos e criamos vari\u00e1veis com MUTATE; contamos o n\u00famero de observa\u00e7\u00f5es de uma vari\u00e1vel com o COUNT e por fim, mudamos o nome de uma vari\u00e1vel com RENAME. Voc\u00ea pode estar pensando: Mas que benef\u00edcio eu tenho com o pipe? Ele otimiza o nosso tempo escrevendo o c\u00f3digo, j\u00e1 que n\u00e3o precisamos escrever os objetos para sobrescrever \u00e0s sa\u00eddas e tamb\u00e9m diminui a complexidade do c\u00f3digo ao mesmo que aumenta sua legibilidade. Em resumo, o pipe, quando utilizado com dplyr tem a seguinte estrutura: Banco de dados Opera\u00e7\u00f5es de manipula\u00e7\u00e3o Joins Muitas vezes precisamos combinar informa\u00e7\u00f5es de tabelas diferentes para conseguir responder as nossas perguntas. Vejamos as tabelas abaixo: knitr::include_graphics(\"imgs/join.png\") Estas duas tabelas s\u00e3o referentes \u00e0 n\u00edvel de colesterol de alguns pacientes e aos registros de atividades f\u00edsicas feitas pelos pacientes por semana; elas s\u00e3o duas tabelas diferentes ligadas apenas pela vari\u00e1vel \u201cID\u201d. Sendo assim, para conect\u00e1-las precisaremos fazer com que exista um match entre ID. Aqui entram os diferentes tipos de \u2018joins\u2019. Os *_join() nada mais s\u00e3o que fun\u00e7\u00f5es que ajudam a combinar duas tabelas atrav\u00e9s de uma \u201cvari\u00e1vel de liga\u00e7\u00e3o\u201d, que normalmente costuma ser uma vari\u00e1vel de identifica\u00e7\u00e3o \u00fanica da observa\u00e7\u00e3o, como por exemplo, o CPF de um indiv\u00edduo. tbl_colesterol <- data.frame(ID = c(\"112\", \"132\", \"345\", \"500\"), NOME = c(\"CAIO\", \"MARIA\", \"ENZO\", \"JULIA\"), COLESTEROL = c(233, 226, 142, 105), stringsAsFactors = FALSE) # PARA EVITAR QUE OS DADOS SEJAM TRANSFORMADOS EM CATEGORICOS tbl_atfisica <- data.frame(ID_PACIENTE = c(\"132\", \"600\", \"500\", \"345\", \"700\"), TIPO = c(\"Futebol\", \"Caminhada\", \"Corrida\", \"Corrida\", \"Nata\u00e7\u00e3o\"), DURACAO_HORAS = c(0.5, 3, 2, 1, 2), ID_atfisica = c(\"12\", \"33\", \"12\", \"38\", \"55\"), stringsAsFactors = FALSE) inner_join() O primeiro join que veremos \u00e9 o inner_join() , que retorna a intersec\u00e7\u00e3o das tabelas tbl_colesterol e tbl_atfisica , ou seja, a sa\u00edda \u00e9 uma nova tabela com informa\u00e7\u00f5es em comum entre os dados. No caso exemplificado, o resultado s\u00e3o tr\u00eas observa\u00e7\u00f5es em comum entre as tabelas dado o mesmo ID. Perceba que para montar a fun\u00e7\u00e3o de join, precisamos de tr\u00eas argumentos: x: que aqui chamaremos de tabela \u00e0 esquerda y: que aqui chamaremos de tabela \u00e0 direita by: argumento que especifica qual \u00e9 a vari\u00e1vel de liga\u00e7\u00e3o entre as tabelas. Caso a vari\u00e1vel tenha o mesmo nome das duas tabelas, voc\u00ea pode colocar apenas o nome da vari\u00e1vel, como por exemplo, by = \"ID\" . Por\u00e9m, caso os nomes sejam diferentes o padr\u00e3o para especificar \u00e9 by = c(\"variavel_tbl_esquerda\" = \"variavel_tbl_direita\") . inner_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) left_join() e right_join() Nesse caso pensamos se queremos que a nossa tabela p\u00f3s join tenha o n\u00famero de linhas da tabela da esqueda ( left_join ) ou da tabela da direita ( right_join ), utilizando o mesmo padr\u00e3o do exemplo anterior. # Left join left_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) Perceba que todas as observa\u00e7\u00f5es da tabela da esquerda est\u00e3o no resultado final, por\u00e9m o ID de n\u00famero 500 tem observa\u00e7\u00f5es missing. Isso se d\u00e1 devido ao fato de que na tabela da direita n\u00e3o existe refer\u00eancia ao seu ID. Caso o intuito seja manter todas as linhas da tabela da direita utilizamos o right_join . # Right join right_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) full_join() Mas se quisermos juntar todas as observa\u00e7\u00f5es das duas tabelas podemos utilizar o full_join full_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) anti_join() E se quisermos somente as observa\u00e7\u00f5es que n\u00e3o d\u00e3o match entre as tabelas? Usamos anti_join() . Por\u00e9m, neste caso, temos que mudar a ordem das tabelas para observar quais casos n\u00e3o deram match. anti_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) anti_join(tbl_atfisica, tbl_colesterol, by = c(\"ID_PACIENTE\" = \"ID\")) # lembre-se de alterar a ordem do by Wrap-up Vamos juntar tudo o que aprendemos e tirar alguma informa\u00e7\u00e3o dos dados? Exiba a m\u00e9dia de colesterol SOMENTE das pessoas em que o valor da press\u00e3o sangu\u00ednea foi maior que a m\u00e9dia das observa\u00e7\u00f5es por sexo e categoria de idade. Tente usar o pipe %>% Respostas - Exerc\u00edcios de revis\u00e3o Exerc\u00edcio 1 dados <- read_csv('heart_mod2.txt') Exerc\u00edcio 2 media_colesterol <- mean(dados$chol) Exerc\u00edcio 3 media_colesterol > dados$chol Exerc\u00edcio 4 dados <- separate(dados, age_sex, c('age', 'sex'), sep = '/')","title":"Transformando Dados"},{"location":"03_transformar/#transformando-dados","text":"","title":"Transformando Dados"},{"location":"03_transformar/#aviso-importante","text":"Antes de come\u00e7ar a programar, atualize o R e seus pacotes rodando os seguintes comandos: install.packages(\"installr\") updateR() Siga as instru\u00e7\u00f5es e em caso de d\u00favidas procure um monitor. Lembre-se de instalar o tidyverse novamente.","title":"Aviso importante!"},{"location":"03_transformar/#atencao-se-liga-ai-que-e-hora-da-revisao-e-dicas","text":"","title":"Aten\u00e7\u00e3o! Se liga a\u00ed que \u00e9 hora da revis\u00e3o (e dicas)!"},{"location":"03_transformar/#scripts","text":"Scripts nada mais s\u00e3o do que uma s\u00e9rie de comandos salvos em um arquivo. Eles s\u00e3o \u00fateis para mantermos a reprodutividade do c\u00f3digo, portanto, sempre que formos utilizar o RStudio \u00e9 recomendado escrever um script.","title":"Scripts"},{"location":"03_transformar/#vetores","text":"Estrutura b\u00e1sica de dados Homog\u00eaneo: aceita apenas um tipo de dado Indexa\u00e7\u00e3o por colchetes simples Apenas 1 n\u00edvel","title":"Vetores"},{"location":"03_transformar/#listas","text":"Estrutura de dados Heterog\u00eaneo: aceita mais de um tipo de dado Indexa\u00e7\u00e3o por colchetes duplo M\u00faltiplos n\u00edveis","title":"Listas"},{"location":"03_transformar/#funcoes","text":"O R base, como chamamos o R sem nenhum pacote instalado por n\u00f3s, j\u00e1 cont\u00e9m diversas fun\u00e7\u00f5es implementadas para realizar a\u00e7\u00f5es sobre os dados que temos a disposi\u00e7\u00e3o. Geralmente, o nome das fun\u00e7\u00f5es j\u00e1 nos d\u00e3o uma no\u00e7\u00e3o de suas a\u00e7\u00f5es. Por exemplo, a fun\u00e7\u00e3o mean() , do portugu\u00eas m\u00e9dia, aplica justamente a m\u00e9dia sobre os dados informados. Para informar os dados e tamb\u00e9m definir alguns dos comportamentos dessa a\u00e7\u00e3o, usamos o par\u00e2metros, que ficam dentro dos par\u00eanteses de cada fun\u00e7\u00e3o.","title":"Fun\u00e7\u00f5es"},{"location":"03_transformar/#exercicios-de-revisao","text":"Para praticarmos algumas coisas que vimos at\u00e9 agora tente fazer os seguintes exerc\u00edcios: Baixe este arquivo e importe-o para seu projeto do RStudio. Calcula a m\u00e9dia de colesterol e armazene-a em um objeto chamado med_colesterol. Verifique se os valores de colesterol de cada observa\u00e7\u00e3o s\u00e3o maiores do que a m\u00e9dia. Separe a coluna age_sex, criando as colunas age e sex com seus respectivos valores.","title":"Exerc\u00edcios de revis\u00e3o"},{"location":"03_transformar/#dplyr-e-suas-funcoes","text":"Para tornar a manipula\u00e7\u00e3o de dados mais eficiente, foi criado um pacote chamado de dplyr que possui uma s\u00e9rie de ferramentas para filtrar, selecionar e sumarizar informa\u00e7\u00f5es, como veremos a seguir.","title":"dplyr e suas fun\u00e7\u00f5es"},{"location":"03_transformar/#funcoes_1","text":"As principais fun\u00e7\u00f5es do dplyr s\u00e3o: filter : filtra as linhas de um banco de dados de acordo com uma regra l\u00f3gica. select : seleciona as colunas de interesse. mutate : modifica ou cria colunas de acordo com valores fornecidos. count : conta os valores de uma vari\u00e1vel. Especialmente \u00fatil para vari\u00e1veis categ\u00f3ricas. rename : altera o nome das vari\u00e1veis (colunas). group_by e summarise : s\u00e3o fun\u00e7\u00f5es normalmente utilizadas em conjunto. Elas permitem realizar opera\u00e7\u00f5es de agrega\u00e7\u00f5es com o banco de dados e, assim, alterar a nossa unidade de an\u00e1lise. Por\u00e9m, n\u00e3o ficaremos apenas nestas fun\u00e7\u00f5es, veremos tamb\u00e9m algumas de suas varia\u00e7\u00f5es e conheceremos o famoso %>% (pipe). Para as atividades abaixo vamos usar o mesmo banco utilizado nos exerc\u00edcios. Como vimos, o dplyr \u00e9 um pacote essencial para manipula\u00e7\u00e3o de dados e uma das suas vantagens \u00e9 que a forma como aplicamos suas fun\u00e7\u00f5es segue o seguinte padr\u00e3o: funcao_dplyr(banco_de_dados, argumentos_especificos) Ou seja, o primeiro argumento de qualquer uma das fun\u00e7\u00f5es \u00e9 o banco de dados, seguido de argumentos espec\u00edficos de cada fun\u00e7\u00e3o, como por exemplo, qual vari\u00e1vel criar ou filtrar.","title":"Fun\u00e7\u00f5es"},{"location":"03_transformar/#filter","text":"Quando estamos fazendo algumas an\u00e1lises, \u00e9 comum encontrarmos observa\u00e7\u00f5es que n\u00e3o nos interessam, como por exemplo, se estou fazendo uma an\u00e1lise sobre pessoas com a\u00e7\u00facar no sangue em jejum menor ou igual do que 120mg/dl, espero que na minha base de dados tenham apenas pessoas que atendam essa condi\u00e7\u00e3o. Para isso utilizamos o filter() , vejamos o exemplo abaixo: filter(dados, fbs == 0) Lembra quando vimos operadores l\u00f3gicos? Pois bem, eles s\u00e3o muito utilizados no filter() . Caso o nosso interesse seja n\u00e3o apenas filtrar sobre a taxa de a\u00e7ucar , mas pessoas do sexo masculino adicionamos o nome da vari\u00e1vel, seguido do condicional filter(dados, fbs == 0, sex == \"Homem\") E se al\u00e9m dos filtros propostos tamb\u00e9m quisermos separar os candidatos com Tipo de dor no peito igual a 1 e 4? Para fazer esse filtro podemos utilizar o operador %in% ! Ele basicamente nos ajuda a filtrar mais de um tipo de categoria de uma vari\u00e1vel, uma vez que o operador == compara apenas uma categoria. filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4)) # perceba a importancia de colocar as categorias que serao filtradas dentro de um vetor Vamos aproveitar para filtrar os casos em que os pacientes n\u00e3o tiveram angina induzida por exerc\u00edcio e guardar esse dado em um objeto chamado amostra1 . amostra1 <- filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1) Agora temos uma outra base de dados para analisarmos. Vamos conhecer ent\u00e3o o select() .","title":"filter()"},{"location":"03_transformar/#select","text":"Em muitas situa\u00e7\u00f5es n\u00f3s n\u00e3o trabalhamos com todas as vari\u00e1veis do banco de dados; para removermos aquelas colunas que n\u00e3o iremos utilizar, adotamos a fun\u00e7\u00e3o select() . Vamos selecionar apenas a idade e a press\u00e3o sangu\u00ednea. select(amostra1, age, trestbps) Percebeu o padr\u00e3o dessa fun\u00e7\u00e3o? Basicamente \u00e9 o banco de dados e as vari\u00e1veis que queremos selecionar. Mas e se quisermos visualizar todas as vari\u00e1veis com exce\u00e7\u00e3o de algumas? select(amostra1, -target, -restecg) No exemplo acima estamos retirando as vari\u00e1veis target e restecg colocando um - na frente dessas vari\u00e1veis. Para darmos continuidade \u00e0s outras fun\u00e7\u00f5es vamos retirar algumas vari\u00e1veis amostra1 <- select(amostra1, -slope, -ca, -thal)","title":"select()"},{"location":"03_transformar/#mutate","text":"Caso tenhamos interesse em alterar ou criar uma vari\u00e1vel, podemos utilizar o mutate() . A fun\u00e7\u00e3o tem o seguinte formato: mutate(bando_de_dados, coluna_nova|coluna_existente = valor) . Vamos aproveitar e alterar a vari\u00e1vel de idade age para n\u00famerico amostra1 <- mutate(amostra1, age = as.numeric(age)) amostra1 Simples n\u00e3o? Al\u00e9m disso, podemos criar vari\u00e1veis categ\u00f3ricas, como por exemplo, uma vari\u00e1vel que identifica se a pessoa tem uma idade maior ou menor de 60 anos. amostra1 <- mutate(amostra1, CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")) amostra1 Perceba que para criar essa vari\u00e1vel utilizamos uma fun\u00e7\u00e3o chamada ifelse() . Basicamente esta fun\u00e7\u00e3o \u00e9 um if em que o primeiro par\u00e2metro \u00e9 a condi\u00e7\u00e3o l\u00f3gica, o segundo \u00e9 a a\u00e7\u00e3o em caso de a condi\u00e7\u00e3o ser verdadeira e o terceiro \u00e9 a a\u00e7\u00e3o no caso de a condi\u00e7\u00e3o ser falsa. Assim, no caso acima ele pergunta: Se o valor da vari\u00e1vel age for menor \u00e0 60, classificamos como \u201cADULTO\u201d, caso negativo, \u201cIDOSO\u201d. Agora que criamos a vari\u00e1vel \u201cCATEGORIA_IDADE\u201d, quantas pessoas s\u00e3o idosas neste experimento? Para respondermos isso podemos utilizar a fun\u00e7\u00e3o count()","title":"mutate()"},{"location":"03_transformar/#count","text":"Em uma tradu\u00e7\u00e3o literal, o count() ir\u00e1 contar as categorias de uma vari\u00e1vel. tabela_cat_idade <- count(amostra1, CATEGORIA_IDADE) tabela_cat_idade Portanto, podemos notar que existem mais adultos em nossa amostra.","title":"count()"},{"location":"03_transformar/#rename","text":"Se quisermos renomear o nome das vari\u00e1veis temos que utilizar o rename() que tem o seguinte padr\u00e3o: rename(bando_de_dados, nome_novo = nome_antigo) tabela_cat_idade <- rename(tabela_cat_idade, Quantidade = n) tabela_cat_idade","title":"rename()"},{"location":"03_transformar/#group_by-e-summarise","text":"O group_by() e summarise() s\u00e3o fun\u00e7\u00f5es que trabalham, na maioria das vezes, juntas. Eles servem para sumarizar os dados de acordo com grupos, ou seja, a contagem que haviamos feito com o count() pode ser reproduzida aqui da seguinte forma: temp_1 <- group_by(amostra1, CATEGORIA_IDADE) temp_1 summarise(temp_1, Quantidade = n()) O objeto temp_1 \u00e9 uma tabela agrupada! Visualmente ela parece normal, por\u00e9m qualquer opera\u00e7\u00e3o feita nela ser\u00e1 realizada de acordo com os grupos nos quais ela encontrou, que neste caso \u00e9: ADULTO e IDOSO. Quando utilizamos o summarise, iremos agrupar as categorias em torno de uma estat\u00edstica, no caso, a contagem. Para fazer isso, utilizamos a fun\u00e7\u00e3o n() , uma fun\u00e7\u00e3o utilizada para contar oberva\u00e7\u00f5es. Caso a vari\u00e1vel que fossemos sumarizar fosse n\u00famerica, poderiamos utilizar a m\u00e9dia ( mean() ), mediana ( median() ) e assim por diante. Portanto, a vantagem do group_by() e summarise() \u00e9 que conseguimos sumarizar com outras estat\u00edsticas al\u00e9m da contagem. Vejamos o exemplo abaixo. Estamos agrupando pela categoria de idade e sexo do indiv\u00edduo. Ap\u00f3s isto, estamos contando o n\u00famero de observa\u00e7\u00f5es que apresentam estas categorias. temp_2 <- group_by(dados, CATEGORIA_IDADE, sex) summarise(temp_2, Quantidade = n()) Com isso podemos verificar que houveram maior participa\u00e7\u00e3o de adultos na amostra.","title":"group_by() e summarise()"},{"location":"03_transformar/#_1","text":"At\u00e9 ent\u00e3o, vimos as principais fun\u00e7\u00f5es do dplyr . Conseguimos extrair uma amostra com caracter\u00edsticas espec\u00edficas e esbo\u00e7ar algumas conclus\u00f5es sua variabilidade. Tamb\u00e9m poder\u00edamos fazer igual ao c\u00f3digo abaixo, por\u00e9m a interpreta\u00e7\u00e3o desse c\u00f3digo se torna mais complexa, uma vez que as a\u00e7\u00f5es s\u00e3o realizadas de dentro pra fora. rename(count(mutate(select(filter(dados, fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1), -slope, -ca, -thal), age = as.numeric(age), CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")), CATEGORIA_IDADE), Quantidade = n) Para solucionar este problema os desenvolvedores do pacote incluiram um operador chamado de pipe ( %>% ). Basicamente ele permite que possamos contruir c\u00f3digos de forma linear, como podemos notar abaixo! dados %>% filter(fbs == 0, sex == \"Homem\", cp %in% c(1, 4), exang != 1) %>% select(-slope, -ca, -thal) %>% mutate(age = as.numeric(age), CATEGORIA_IDADE = ifelse(age >= 60, \"IDOSO\", \"ADULTO\")) %>% count(CATEGORIA_IDADE) %>% rename(Quantidade = n) Agora podemos interpretar o c\u00f3digo acima da seguinte maneira: Pegamos a nossa base de dados sobre doen\u00e7as card\u00edacas com o nome \u201cdados\u201d, aplicamos um FILTER para filtrar as observa\u00e7\u00f5es do banco, em seguida o SELECT para removermos colunas que n\u00e3o queremos. Depois alteramos e criamos vari\u00e1veis com MUTATE; contamos o n\u00famero de observa\u00e7\u00f5es de uma vari\u00e1vel com o COUNT e por fim, mudamos o nome de uma vari\u00e1vel com RENAME. Voc\u00ea pode estar pensando: Mas que benef\u00edcio eu tenho com o pipe? Ele otimiza o nosso tempo escrevendo o c\u00f3digo, j\u00e1 que n\u00e3o precisamos escrever os objetos para sobrescrever \u00e0s sa\u00eddas e tamb\u00e9m diminui a complexidade do c\u00f3digo ao mesmo que aumenta sua legibilidade. Em resumo, o pipe, quando utilizado com dplyr tem a seguinte estrutura: Banco de dados Opera\u00e7\u00f5es de manipula\u00e7\u00e3o","title":"%&gt;%"},{"location":"03_transformar/#joins","text":"Muitas vezes precisamos combinar informa\u00e7\u00f5es de tabelas diferentes para conseguir responder as nossas perguntas. Vejamos as tabelas abaixo: knitr::include_graphics(\"imgs/join.png\") Estas duas tabelas s\u00e3o referentes \u00e0 n\u00edvel de colesterol de alguns pacientes e aos registros de atividades f\u00edsicas feitas pelos pacientes por semana; elas s\u00e3o duas tabelas diferentes ligadas apenas pela vari\u00e1vel \u201cID\u201d. Sendo assim, para conect\u00e1-las precisaremos fazer com que exista um match entre ID. Aqui entram os diferentes tipos de \u2018joins\u2019. Os *_join() nada mais s\u00e3o que fun\u00e7\u00f5es que ajudam a combinar duas tabelas atrav\u00e9s de uma \u201cvari\u00e1vel de liga\u00e7\u00e3o\u201d, que normalmente costuma ser uma vari\u00e1vel de identifica\u00e7\u00e3o \u00fanica da observa\u00e7\u00e3o, como por exemplo, o CPF de um indiv\u00edduo. tbl_colesterol <- data.frame(ID = c(\"112\", \"132\", \"345\", \"500\"), NOME = c(\"CAIO\", \"MARIA\", \"ENZO\", \"JULIA\"), COLESTEROL = c(233, 226, 142, 105), stringsAsFactors = FALSE) # PARA EVITAR QUE OS DADOS SEJAM TRANSFORMADOS EM CATEGORICOS tbl_atfisica <- data.frame(ID_PACIENTE = c(\"132\", \"600\", \"500\", \"345\", \"700\"), TIPO = c(\"Futebol\", \"Caminhada\", \"Corrida\", \"Corrida\", \"Nata\u00e7\u00e3o\"), DURACAO_HORAS = c(0.5, 3, 2, 1, 2), ID_atfisica = c(\"12\", \"33\", \"12\", \"38\", \"55\"), stringsAsFactors = FALSE)","title":"Joins"},{"location":"03_transformar/#inner_join","text":"O primeiro join que veremos \u00e9 o inner_join() , que retorna a intersec\u00e7\u00e3o das tabelas tbl_colesterol e tbl_atfisica , ou seja, a sa\u00edda \u00e9 uma nova tabela com informa\u00e7\u00f5es em comum entre os dados. No caso exemplificado, o resultado s\u00e3o tr\u00eas observa\u00e7\u00f5es em comum entre as tabelas dado o mesmo ID. Perceba que para montar a fun\u00e7\u00e3o de join, precisamos de tr\u00eas argumentos: x: que aqui chamaremos de tabela \u00e0 esquerda y: que aqui chamaremos de tabela \u00e0 direita by: argumento que especifica qual \u00e9 a vari\u00e1vel de liga\u00e7\u00e3o entre as tabelas. Caso a vari\u00e1vel tenha o mesmo nome das duas tabelas, voc\u00ea pode colocar apenas o nome da vari\u00e1vel, como por exemplo, by = \"ID\" . Por\u00e9m, caso os nomes sejam diferentes o padr\u00e3o para especificar \u00e9 by = c(\"variavel_tbl_esquerda\" = \"variavel_tbl_direita\") . inner_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\"))","title":"inner_join()"},{"location":"03_transformar/#left_join-e-right_join","text":"Nesse caso pensamos se queremos que a nossa tabela p\u00f3s join tenha o n\u00famero de linhas da tabela da esqueda ( left_join ) ou da tabela da direita ( right_join ), utilizando o mesmo padr\u00e3o do exemplo anterior. # Left join left_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) Perceba que todas as observa\u00e7\u00f5es da tabela da esquerda est\u00e3o no resultado final, por\u00e9m o ID de n\u00famero 500 tem observa\u00e7\u00f5es missing. Isso se d\u00e1 devido ao fato de que na tabela da direita n\u00e3o existe refer\u00eancia ao seu ID. Caso o intuito seja manter todas as linhas da tabela da direita utilizamos o right_join . # Right join right_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\"))","title":"left_join() e right_join()"},{"location":"03_transformar/#full_join","text":"Mas se quisermos juntar todas as observa\u00e7\u00f5es das duas tabelas podemos utilizar o full_join full_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\"))","title":"full_join()"},{"location":"03_transformar/#anti_join","text":"E se quisermos somente as observa\u00e7\u00f5es que n\u00e3o d\u00e3o match entre as tabelas? Usamos anti_join() . Por\u00e9m, neste caso, temos que mudar a ordem das tabelas para observar quais casos n\u00e3o deram match. anti_join(tbl_colesterol, tbl_atfisica, by = c(\"ID\" = \"ID_PACIENTE\")) anti_join(tbl_atfisica, tbl_colesterol, by = c(\"ID_PACIENTE\" = \"ID\")) # lembre-se de alterar a ordem do by","title":"anti_join()"},{"location":"03_transformar/#wrap-up","text":"Vamos juntar tudo o que aprendemos e tirar alguma informa\u00e7\u00e3o dos dados? Exiba a m\u00e9dia de colesterol SOMENTE das pessoas em que o valor da press\u00e3o sangu\u00ednea foi maior que a m\u00e9dia das observa\u00e7\u00f5es por sexo e categoria de idade. Tente usar o pipe %>%","title":"Wrap-up"},{"location":"03_transformar/#respostas-exercicios-de-revisao","text":"Exerc\u00edcio 1 dados <- read_csv('heart_mod2.txt') Exerc\u00edcio 2 media_colesterol <- mean(dados$chol) Exerc\u00edcio 3 media_colesterol > dados$chol Exerc\u00edcio 4 dados <- separate(dados, age_sex, c('age', 'sex'), sep = '/')","title":"Respostas - Exerc\u00edcios de revis\u00e3o"},{"location":"04_visualizacao/","text":"As visualiza\u00e7\u00f5es gr\u00e1ficas s\u00e3o muito importantes para transmitir informa\u00e7\u00f5es. Podemos dizer at\u00e9 que ela \u00e9 fundamental para an\u00e1lise de dados, nos ajudando a responder quest\u00f5es, tomar decis\u00f5es, contar hist\u00f3rias e at\u00e9 mesmo inspirar. Veremos n\u00e3o s\u00f3 como fazer estas visualiza\u00e7\u00f5es, mas tamb\u00e9m a entender quando elas podem ser necess\u00e1rias. Al\u00e9m disso, vamos aproveitar para rever alguns t\u00f3picos de aulas passadas utilizando informa\u00e7\u00f5es de corridas de taxi em NYC. Para ter mais contexto, estamos desenvolvendo uma nova feature/solu\u00e7\u00e3o de incentivo para os usu\u00e1rios . Para isso precisamos entender quais grupos utilizam mais a nossa plataforma. O banco de dados possu\u00ed 166.355 entradas com 18 vari\u00e1veis: Vari\u00e1vel Descri\u00e7\u00e3o id Identifica\u00e7\u00e3o da corrida date_pickup Data de entrada no ve\u00edculo hour_pickup Hora de entrada no ve\u00edculo dayweek_pickup Dia da semana de entrada no ve\u00edculo date_dropoff Data de saida do ve\u00edculo hour_dropoff Hora de saida do ve\u00edculo dayweek_dropoff Dia da semana de saida do ve\u00edculo passenger_count Quantos passageiros estavam no carro pickup_latitude Latitude de entrada no carro pickup_longitude Longitude de entrada no carro dropoff_latitude Latitude de saida do carro dropoff_longitude Longitude de saida do carro duration Dura\u00e7\u00e3o da corrida (em segundos) distance Dist\u00e2ncia da corrida (em milhas) rating Nota da corrida age Idade do passageiro que pediu a corrida price Pre\u00e7o final da corrida comments Coment\u00e1rios ao final da corrida Vamos aprender a fazer visualizac\u00f5es? Download do Banco Sempre \u00e9 bom recaptular. Para abrir este banco de dados podemos utilizar qual pacote? library(<pacote>) banco <- read_<nome>(<caminho_do_arquivo>) library(readr) banco <- read_csv(\"taxirides_sample.csv\") 1. ggplot2 Antes de irmos diretamente para as visualiza\u00e7\u00f5es vamos habilitar alguns pacotes: library(tidyverse) #install.packages(\"Amelia\") library(Amelia) Habilitamos dois pacotes novos, o ggplot2 e o Amelia . O primeiro deles \u00e9 o principal pacote para visualiza\u00e7\u00f5es no R, possibilitando criar gr\u00e1ficos exatamente da forma que voc\u00ea quiser, sobretudo, porque ele funciona em um esquema de layers. O segundo pacote \u00e9 feito para visualizarmos valores ausentes entre vari\u00e1veis, tamb\u00e9m chamado de NA . Apesar dele n\u00e3o fazer parte do ggplot2 , \u00e9 uma ot\u00edma alternativa identificarmos valores ausentes. Mas antes vamos tratar de entender a nossa base de dados e fazer algumas manipula\u00e7\u00f5es nela. A primeira coisa que iremos fazer \u00e9 aplicar a fun\u00e7\u00e3o glimpse() do dplyr . Elas nos possibilita ver as nossas vari\u00e1veis sem precisar abrir o banco inteiro. glimpse(banco) Pode-se notar que todas as vari\u00e1veis parecem ok! Ser\u00e1 mesmo? Se voc\u00ea notou temos duas vari\u00e1vel que n\u00e3o deveria estar a\u00ed, a X14 e a X15. Al\u00e9m disso, vamos investigar se nosso dado possui valores ausentes? Exerc\u00edcio Remova as vari\u00e1veis X14 e X15. Depois filtre: para uma dura\u00e7\u00e3o menor ou igual a 1000 segundos; e distancia menor do que 100 milhas. Este filtro \u00e9 para restringirmos mais a nossa an\u00e1lise dado a quantidade de dados. banco <- banco %>% select(-X14,-X15) %>% filter(duration <= 1000, distance <= 100) Vamos verificar os valores ausentes do nosso banco? Amelia::missmap(banco) AHA! Temos valores ausentes na coluna comments . Vamos remov\u00ea-la! Filtre apenas por valores que n\u00e3o possuem NA banco <- banco %>% select(-comments) Amelia::missmap(banco) Calcule a m\u00e9dia do pre\u00e7o (media_global) das corridas. E partir disso, classifique se o pre\u00e7o de cada corrida \u00e9 Maior ou Menor que a media_global (transforme o resultado em fator) media_global <- mean(banco$price) banco <- banco %>% mutate(categoria_preco = ifelse(price >= media_global, \"Maior\", \"Menor\"), categoria_preco = factor(categoria_preco, levels = c(\"Maior\", \"Menor\"))) head(banco) Por fim, temos uma vari\u00e1vel chamada age . Transforme ela em conjunto de categorias utilizando a fun\u00e7\u00e3o case_when() e depois transforme o resultado em fator banco %>% summarise(min = min(age), max = max(age)) banco <- banco %>% mutate(categoria_idade = case_when(age %in% c(18:24) ~ \"18_24\", age %in% c(25:34) ~ \"25_34\", age %in% c(35:44) ~ \"35_44\", age %in% c(45:54) ~ \"45_54\", age %in% c(55:65) ~ \"55_65\"), categoria_idade = factor(categoria_idade, levels = c(\"18_24\", \"25_34\", \"35_44\", \"45_54\", \"55_65\"))) banco %>% count(categoria_idade) Agora que alteramos e criamos algumas vari\u00e1veis vamos conhecer o ggplot2 . ggplot2 O ggplot2 \u00e9 um pacote baseado no que se chamou Grammar of Graphics (por isso gg antes do plot2), que nada mais \u00e9 do que uma estrutura (framework) para realiza\u00e7\u00e3o de gr\u00e1ficos, que n\u00f3s tamb\u00e9m chamamos de \u201cplot\u201d. Al\u00e9m disso, o Grammar of Graphics tem o seguinte principio: Layers Gr\u00e1ficos s\u00e3o constru\u00eddos com diferentes layers Mas o que s\u00e3o layers ? Layers s\u00e3o elementos (ou componentes) gram\u00e1ticais utilizados para fazer um plot. Estes componentes s\u00e3o importantes para determinar a representa\u00e7\u00e3o dos dados. Como o Hadley Wickham apontou em um artigo chamado \u201cA layered grammar of graphics\u201d (2010), a associa\u00e7\u00e3o destes layers com uma certa gr\u00e1matica auxilia o usu\u00e1rio em atualizar e contruir gr\u00e1ficos com uma facilidade maior. Os elementos gram\u00e1ticais que temos no ggplot2 s\u00e3o: Data - O dado que ser\u00e1 plotado, mapeando as vari\u00e1veis de interesse. Aesthetics - A escala em que o dado ser\u00e1 plotado, sinalizando os eixos x e y, cor, tamanho, preenchimento e etc. Geom - Estrutura que ser\u00e1 utilizada nos seus dados, como por exemplo, gr\u00e1fico de dispers\u00e3o, linha, boxplot e etc. Facets - plotar multiplos grupos Stats - Transforma\u00e7\u00f5es estat\u00edsticas Coordinates System - O espa\u00e7o no qual o dado sera plotado, como por exemplo, espa\u00e7o cartesiano, polar e entre outros. Theme - Controle e modifica\u00e7\u00e3o de apar\u00eancia de tudo que n\u00e3o diz respeito ao dado utilizado. Scales - Para cada Aesthetics, descreve como a caracter\u00edstica visual \u00e9 convertida em valores, como por exemplo, escala por tamanho, cor e etc. \u00c9 muito importante destacar que as camadas (layers) podem aparecer em qualquer sequencia ao fazermos um gr\u00e1fico e que a \u00fanica camada necess\u00e1ria para come\u00e7ar um gr\u00e1fico \u00e9 a partir da fun\u00e7\u00e3o ggplot() . Os layers do ggplot2 (Fonte: DataCamp) Como fazer um gr\u00e1fico no ggplot2 Vamos fazer um exerc\u00edcio de imagina\u00e7\u00e3o? Como n\u00f3s far\u00edamos um gr\u00e1fico sem o R? Que tal um papel? Qual o passo a passo que poder\u00edamos fazer? No R \u00e9 semelhante. Primeiro precisamos de um papel: ggplot() Depois, n\u00f3s precisamos decidir que dados iremos utilizar e quam vai ser o eixo x e o eixo y. ggplot(data = banco, mapping = aes(x = duration , y = distance)) Em seguida, escolhemos qual \u00e9 melhor forma /estrutura para visualizar os dados. ggplot(data = banco, mapping = aes(x = duration , y = distance)) + geom_point() Qual \u00e9 a diferen\u00e7a do + para o %>% Como vimos o pipe serve para deixarmos a linguagem mais linear, servindo como um conector entre as fun\u00e7\u00f5es, por\u00e9m isso n\u00e3o funciona com o ggplot2 . O motivo pode ser pensado at\u00e9 de forma mais intuitiva: No ggplot2 estamos adicionando camadas com o sinal de mais enquanto com o %>% estamos dando uma sequ\u00eancia de a\u00e7\u00f5es, isto \u00e9, fun\u00e7\u00f5es. Simples, n\u00e3o? Apesar disso, precisamos entender alguns conceitos que vimos ao montar este gr\u00e1fico, como por exemplo, colocamos os eixos x e y dentro de uma fun\u00e7\u00e3o chamada aes() . Ela \u00e9 uma fun\u00e7\u00e3o respons\u00e1vel pela propriedade visual dos objetos no gr\u00e1fico, em outras palavras, ela faz o \u201cmapeamento\u201d das vari\u00e1veis do nosso banco de dados para que eles possam fazer parte dos elementos visuais do gr\u00e1fico. ggplot(data = banco, mapping = aes(x = duration , y = distance, color = categoria_idade)) + geom_point() Perceba que o color = categoria_idade afeta o geom que utilizamos de acordo com a vari\u00e1vel de interesse, mas veremos adiante que tamb\u00e9m podemos alterar tanto um geom especificamente, quanto a cor do gr\u00e1fico. Antes de explorarmos outros geoms, que hip\u00f3teses podemos levantar desse gr\u00e1fico? Vamos ver outros geom_ ? geom_col() Para fazer este geom, eu vou manipular a base de dados para contar corridas tiveram um pre\u00e7o menor e maior do que a m\u00e9dia. Al\u00e9m disso, vou chamar essa nova tabela de tab1 # chame esta tabela de banco para que possamos fazer outras manipula\u00e7\u00f5es tab1 <- banco %>% group_by(categoria_preco) %>% summarise(n = n()) tab1 Vamos para o geom_col() ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n)) + geom_col() Vamos brincar um pouco com os argumentos est\u00e9ticos que o ggplot2 permite? ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n)) + geom_col(fill = \"red\", width = 0.5) Exerc\u00edcio Aplique os par\u00e2metros para mudar a cor (color), o tamanho (size) e o formato (shape) dos pontos do gr\u00e1fico abaixo: ggplot(data = banco, mapping = aes(x = duration, y = price)) + geom_point() geom_histogram() e geom_density() Se quisermos ver a distribui\u00e7\u00e3o de uma vari\u00e1vel quantitativa, podemos utilizar o geom_histogram() ! Qual ser\u00e1 a distribui\u00e7\u00e3o da vari\u00e1vel price? ggplot(banco, aes(x = duration)) + geom_histogram(bins = 20) Lembre-se que tamb\u00e9m podemos colocar outros atribuitos est\u00e9ticos! ggplot(banco, aes(x = duration)) + geom_histogram(bins = 20, color = \"blue\", fill = \"green\") Al\u00e9m do geom_histogram() , o R tamb\u00e9m nos permite aplicar o geom_density() em vari\u00e1veis contin\u00faas! Vamos ver como ficam os casos acima: ggplot(banco, aes(x = duration)) + geom_density(color = \"blue\", fill = \"green\", alpha = 0.5) E se eu quiser comparar a distribui\u00e7\u00e3o da dura\u00e7\u00e3o pelo pre\u00e7o (categoria_pre\u00e7o)? ggplot(banco, aes(x = duration, fill = categoria_preco)) + geom_density(color = \"blue\", alpha = 0.5) geom_boxplot() e geom_violin() Se n\u00f3s tivermos uma vari\u00e1vel quantitativa e qualitativa, podemos utilizar o geom_boxplot e o geom_violin ! Qual a distribui\u00e7\u00e3o da m\u00e9dia de nota por macro distrito? ggplot(banco, aes(x = categoria_idade, y = price)) + geom_boxplot(fill = \"#444054\", color = \"#cc3f0c\") ggplot(banco, aes(x = categoria_idade, y = price)) + geom_violin(fill = \"#8c1c13\", alpha = 1/2) geom_line() Para esses exemplo vamos criar a tabela abaixo primeiro: tab2 <- banco %>% group_by(hour_pickup) %>% summarise(price_hour_pickup = mean(price)) Apesar de mais utilizado para s\u00e9ries temporais, podemos utilizar um gr\u00e1fico de linhas para pensar na varia\u00e7\u00e3o do pre\u00e7o ao longo do dia. ggplot(data = tab2, mapping = aes(x = hour_pickup, y = price_hour_pickup)) + geom_line(group = 1) Exerc\u00edcio Incluia um geom_point() no gr\u00e1fico acima e altere sua cor. E se quisermos mudar a cor da categoriza\u00e7\u00e3o para algo que gostamos mais? Para fazer isso vamos incluir mais uma camada no nosso gr\u00e1fico, a camada de scale. Combinando cores Se voc\u00ea tem d\u00favida de qual cor pode combinar melhor com outra, tem um site bem bacana que pode te ajudar nisso. tab3 <- banco %>% group_by(hour_pickup) %>% summarise(price_hour_pickup = mean(price)) ggplot(data = tab2, mapping = aes(x = hour_pickup, y = price_hour_pickup)) + geom_line(group = 1, color = \"#8093F1\", size = 1) + geom_point(size = 2, color = \"#ff1053\") Podemos utilizar o scale_color_manual para preencher as cores de acordo com o param\u00eatro color . Se voc\u00ea quiser escolher o fill teriamos que utilizar scale_fill_manual . ggplot(banco, aes(x = categoria_idade, y = price, fill = categoria_idade)) + geom_boxplot(color = \"#023047\", alpha = 0.7) + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) O ggplot2 tamb\u00e9m possibilita a utiliza\u00e7\u00e3o de outros sistemas de coordenadas, como por exemplo: coord_flip ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n, fill = categoria_preco)) + geom_col() + scale_fill_manual(values = c(\"#ff1053\", \"#6c6ea0\")) + coord_flip() coord_polar tab4 <- banco %>% group_by(categoria_idade) %>% summarise(n = n()) %>% mutate(p = n/sum(n)) ggplot(data = tab4, mapping = aes(x = factor(1), y = p, fill = categoria_idade)) + geom_col() + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) + coord_polar(theta = 'y') Dica: Tome cuidado com o coord_polar ! \u00c1s vezes, para n\u00e3o dizer sempre, eles podem dificultar a visualiza\u00e7\u00e3o dos dados, sobretudo, aqueles com muitas categorias. Vamos dar um t\u00edtulo para nosso gr\u00e1fico? ggplot(data = tab4, mapping = aes(x = factor(1), y = p, fill = categoria_idade)) + geom_col() + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) + coord_polar(theta = 'y') + labs(title = \"As idades n\u00e3o possuem diferen\u00e7as\\nnot\u00e1veis quando em compara\u00e7\u00e3o\", x = \"EIXO X\", y = \"EIXO Y\", caption = \"TAXI DATA\") + theme_bw()","title":"Visualizacao"},{"location":"04_visualizacao/#1-ggplot2","text":"Antes de irmos diretamente para as visualiza\u00e7\u00f5es vamos habilitar alguns pacotes: library(tidyverse) #install.packages(\"Amelia\") library(Amelia) Habilitamos dois pacotes novos, o ggplot2 e o Amelia . O primeiro deles \u00e9 o principal pacote para visualiza\u00e7\u00f5es no R, possibilitando criar gr\u00e1ficos exatamente da forma que voc\u00ea quiser, sobretudo, porque ele funciona em um esquema de layers. O segundo pacote \u00e9 feito para visualizarmos valores ausentes entre vari\u00e1veis, tamb\u00e9m chamado de NA . Apesar dele n\u00e3o fazer parte do ggplot2 , \u00e9 uma ot\u00edma alternativa identificarmos valores ausentes. Mas antes vamos tratar de entender a nossa base de dados e fazer algumas manipula\u00e7\u00f5es nela. A primeira coisa que iremos fazer \u00e9 aplicar a fun\u00e7\u00e3o glimpse() do dplyr . Elas nos possibilita ver as nossas vari\u00e1veis sem precisar abrir o banco inteiro. glimpse(banco) Pode-se notar que todas as vari\u00e1veis parecem ok! Ser\u00e1 mesmo? Se voc\u00ea notou temos duas vari\u00e1vel que n\u00e3o deveria estar a\u00ed, a X14 e a X15. Al\u00e9m disso, vamos investigar se nosso dado possui valores ausentes?","title":"1. ggplot2"},{"location":"04_visualizacao/#exercicio","text":"Remova as vari\u00e1veis X14 e X15. Depois filtre: para uma dura\u00e7\u00e3o menor ou igual a 1000 segundos; e distancia menor do que 100 milhas. Este filtro \u00e9 para restringirmos mais a nossa an\u00e1lise dado a quantidade de dados. banco <- banco %>% select(-X14,-X15) %>% filter(duration <= 1000, distance <= 100) Vamos verificar os valores ausentes do nosso banco? Amelia::missmap(banco) AHA! Temos valores ausentes na coluna comments . Vamos remov\u00ea-la! Filtre apenas por valores que n\u00e3o possuem NA banco <- banco %>% select(-comments) Amelia::missmap(banco) Calcule a m\u00e9dia do pre\u00e7o (media_global) das corridas. E partir disso, classifique se o pre\u00e7o de cada corrida \u00e9 Maior ou Menor que a media_global (transforme o resultado em fator) media_global <- mean(banco$price) banco <- banco %>% mutate(categoria_preco = ifelse(price >= media_global, \"Maior\", \"Menor\"), categoria_preco = factor(categoria_preco, levels = c(\"Maior\", \"Menor\"))) head(banco) Por fim, temos uma vari\u00e1vel chamada age . Transforme ela em conjunto de categorias utilizando a fun\u00e7\u00e3o case_when() e depois transforme o resultado em fator banco %>% summarise(min = min(age), max = max(age)) banco <- banco %>% mutate(categoria_idade = case_when(age %in% c(18:24) ~ \"18_24\", age %in% c(25:34) ~ \"25_34\", age %in% c(35:44) ~ \"35_44\", age %in% c(45:54) ~ \"45_54\", age %in% c(55:65) ~ \"55_65\"), categoria_idade = factor(categoria_idade, levels = c(\"18_24\", \"25_34\", \"35_44\", \"45_54\", \"55_65\"))) banco %>% count(categoria_idade) Agora que alteramos e criamos algumas vari\u00e1veis vamos conhecer o ggplot2 .","title":"Exerc\u00edcio"},{"location":"04_visualizacao/#ggplot2","text":"O ggplot2 \u00e9 um pacote baseado no que se chamou Grammar of Graphics (por isso gg antes do plot2), que nada mais \u00e9 do que uma estrutura (framework) para realiza\u00e7\u00e3o de gr\u00e1ficos, que n\u00f3s tamb\u00e9m chamamos de \u201cplot\u201d. Al\u00e9m disso, o Grammar of Graphics tem o seguinte principio: Layers Gr\u00e1ficos s\u00e3o constru\u00eddos com diferentes layers Mas o que s\u00e3o layers ? Layers s\u00e3o elementos (ou componentes) gram\u00e1ticais utilizados para fazer um plot. Estes componentes s\u00e3o importantes para determinar a representa\u00e7\u00e3o dos dados. Como o Hadley Wickham apontou em um artigo chamado \u201cA layered grammar of graphics\u201d (2010), a associa\u00e7\u00e3o destes layers com uma certa gr\u00e1matica auxilia o usu\u00e1rio em atualizar e contruir gr\u00e1ficos com uma facilidade maior. Os elementos gram\u00e1ticais que temos no ggplot2 s\u00e3o: Data - O dado que ser\u00e1 plotado, mapeando as vari\u00e1veis de interesse. Aesthetics - A escala em que o dado ser\u00e1 plotado, sinalizando os eixos x e y, cor, tamanho, preenchimento e etc. Geom - Estrutura que ser\u00e1 utilizada nos seus dados, como por exemplo, gr\u00e1fico de dispers\u00e3o, linha, boxplot e etc. Facets - plotar multiplos grupos Stats - Transforma\u00e7\u00f5es estat\u00edsticas Coordinates System - O espa\u00e7o no qual o dado sera plotado, como por exemplo, espa\u00e7o cartesiano, polar e entre outros. Theme - Controle e modifica\u00e7\u00e3o de apar\u00eancia de tudo que n\u00e3o diz respeito ao dado utilizado. Scales - Para cada Aesthetics, descreve como a caracter\u00edstica visual \u00e9 convertida em valores, como por exemplo, escala por tamanho, cor e etc. \u00c9 muito importante destacar que as camadas (layers) podem aparecer em qualquer sequencia ao fazermos um gr\u00e1fico e que a \u00fanica camada necess\u00e1ria para come\u00e7ar um gr\u00e1fico \u00e9 a partir da fun\u00e7\u00e3o ggplot() . Os layers do ggplot2 (Fonte: DataCamp)","title":"ggplot2"},{"location":"04_visualizacao/#como-fazer-um-grafico-no-ggplot2","text":"Vamos fazer um exerc\u00edcio de imagina\u00e7\u00e3o? Como n\u00f3s far\u00edamos um gr\u00e1fico sem o R? Que tal um papel? Qual o passo a passo que poder\u00edamos fazer? No R \u00e9 semelhante. Primeiro precisamos de um papel: ggplot() Depois, n\u00f3s precisamos decidir que dados iremos utilizar e quam vai ser o eixo x e o eixo y. ggplot(data = banco, mapping = aes(x = duration , y = distance)) Em seguida, escolhemos qual \u00e9 melhor forma /estrutura para visualizar os dados. ggplot(data = banco, mapping = aes(x = duration , y = distance)) + geom_point() Qual \u00e9 a diferen\u00e7a do + para o %>% Como vimos o pipe serve para deixarmos a linguagem mais linear, servindo como um conector entre as fun\u00e7\u00f5es, por\u00e9m isso n\u00e3o funciona com o ggplot2 . O motivo pode ser pensado at\u00e9 de forma mais intuitiva: No ggplot2 estamos adicionando camadas com o sinal de mais enquanto com o %>% estamos dando uma sequ\u00eancia de a\u00e7\u00f5es, isto \u00e9, fun\u00e7\u00f5es. Simples, n\u00e3o? Apesar disso, precisamos entender alguns conceitos que vimos ao montar este gr\u00e1fico, como por exemplo, colocamos os eixos x e y dentro de uma fun\u00e7\u00e3o chamada aes() . Ela \u00e9 uma fun\u00e7\u00e3o respons\u00e1vel pela propriedade visual dos objetos no gr\u00e1fico, em outras palavras, ela faz o \u201cmapeamento\u201d das vari\u00e1veis do nosso banco de dados para que eles possam fazer parte dos elementos visuais do gr\u00e1fico. ggplot(data = banco, mapping = aes(x = duration , y = distance, color = categoria_idade)) + geom_point() Perceba que o color = categoria_idade afeta o geom que utilizamos de acordo com a vari\u00e1vel de interesse, mas veremos adiante que tamb\u00e9m podemos alterar tanto um geom especificamente, quanto a cor do gr\u00e1fico. Antes de explorarmos outros geoms, que hip\u00f3teses podemos levantar desse gr\u00e1fico? Vamos ver outros geom_ ?","title":"Como fazer um gr\u00e1fico no ggplot2"},{"location":"04_visualizacao/#geom_col","text":"Para fazer este geom, eu vou manipular a base de dados para contar corridas tiveram um pre\u00e7o menor e maior do que a m\u00e9dia. Al\u00e9m disso, vou chamar essa nova tabela de tab1 # chame esta tabela de banco para que possamos fazer outras manipula\u00e7\u00f5es tab1 <- banco %>% group_by(categoria_preco) %>% summarise(n = n()) tab1 Vamos para o geom_col() ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n)) + geom_col() Vamos brincar um pouco com os argumentos est\u00e9ticos que o ggplot2 permite? ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n)) + geom_col(fill = \"red\", width = 0.5)","title":"geom_col()"},{"location":"04_visualizacao/#exercicio_1","text":"Aplique os par\u00e2metros para mudar a cor (color), o tamanho (size) e o formato (shape) dos pontos do gr\u00e1fico abaixo: ggplot(data = banco, mapping = aes(x = duration, y = price)) + geom_point()","title":"Exerc\u00edcio"},{"location":"04_visualizacao/#geom_histogram-e-geom_density","text":"Se quisermos ver a distribui\u00e7\u00e3o de uma vari\u00e1vel quantitativa, podemos utilizar o geom_histogram() ! Qual ser\u00e1 a distribui\u00e7\u00e3o da vari\u00e1vel price? ggplot(banco, aes(x = duration)) + geom_histogram(bins = 20) Lembre-se que tamb\u00e9m podemos colocar outros atribuitos est\u00e9ticos! ggplot(banco, aes(x = duration)) + geom_histogram(bins = 20, color = \"blue\", fill = \"green\") Al\u00e9m do geom_histogram() , o R tamb\u00e9m nos permite aplicar o geom_density() em vari\u00e1veis contin\u00faas! Vamos ver como ficam os casos acima: ggplot(banco, aes(x = duration)) + geom_density(color = \"blue\", fill = \"green\", alpha = 0.5) E se eu quiser comparar a distribui\u00e7\u00e3o da dura\u00e7\u00e3o pelo pre\u00e7o (categoria_pre\u00e7o)? ggplot(banco, aes(x = duration, fill = categoria_preco)) + geom_density(color = \"blue\", alpha = 0.5)","title":"geom_histogram() e geom_density()"},{"location":"04_visualizacao/#geom_boxplot-e-geom_violin","text":"Se n\u00f3s tivermos uma vari\u00e1vel quantitativa e qualitativa, podemos utilizar o geom_boxplot e o geom_violin ! Qual a distribui\u00e7\u00e3o da m\u00e9dia de nota por macro distrito? ggplot(banco, aes(x = categoria_idade, y = price)) + geom_boxplot(fill = \"#444054\", color = \"#cc3f0c\") ggplot(banco, aes(x = categoria_idade, y = price)) + geom_violin(fill = \"#8c1c13\", alpha = 1/2)","title":"geom_boxplot() e geom_violin()"},{"location":"04_visualizacao/#geom_line","text":"Para esses exemplo vamos criar a tabela abaixo primeiro: tab2 <- banco %>% group_by(hour_pickup) %>% summarise(price_hour_pickup = mean(price)) Apesar de mais utilizado para s\u00e9ries temporais, podemos utilizar um gr\u00e1fico de linhas para pensar na varia\u00e7\u00e3o do pre\u00e7o ao longo do dia. ggplot(data = tab2, mapping = aes(x = hour_pickup, y = price_hour_pickup)) + geom_line(group = 1)","title":"geom_line()"},{"location":"04_visualizacao/#exercicio_2","text":"Incluia um geom_point() no gr\u00e1fico acima e altere sua cor. E se quisermos mudar a cor da categoriza\u00e7\u00e3o para algo que gostamos mais? Para fazer isso vamos incluir mais uma camada no nosso gr\u00e1fico, a camada de scale. Combinando cores Se voc\u00ea tem d\u00favida de qual cor pode combinar melhor com outra, tem um site bem bacana que pode te ajudar nisso. tab3 <- banco %>% group_by(hour_pickup) %>% summarise(price_hour_pickup = mean(price)) ggplot(data = tab2, mapping = aes(x = hour_pickup, y = price_hour_pickup)) + geom_line(group = 1, color = \"#8093F1\", size = 1) + geom_point(size = 2, color = \"#ff1053\") Podemos utilizar o scale_color_manual para preencher as cores de acordo com o param\u00eatro color . Se voc\u00ea quiser escolher o fill teriamos que utilizar scale_fill_manual . ggplot(banco, aes(x = categoria_idade, y = price, fill = categoria_idade)) + geom_boxplot(color = \"#023047\", alpha = 0.7) + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) O ggplot2 tamb\u00e9m possibilita a utiliza\u00e7\u00e3o de outros sistemas de coordenadas, como por exemplo: coord_flip ggplot(data = tab1, mapping = aes(x = categoria_preco, y = n, fill = categoria_preco)) + geom_col() + scale_fill_manual(values = c(\"#ff1053\", \"#6c6ea0\")) + coord_flip() coord_polar tab4 <- banco %>% group_by(categoria_idade) %>% summarise(n = n()) %>% mutate(p = n/sum(n)) ggplot(data = tab4, mapping = aes(x = factor(1), y = p, fill = categoria_idade)) + geom_col() + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) + coord_polar(theta = 'y') Dica: Tome cuidado com o coord_polar ! \u00c1s vezes, para n\u00e3o dizer sempre, eles podem dificultar a visualiza\u00e7\u00e3o dos dados, sobretudo, aqueles com muitas categorias. Vamos dar um t\u00edtulo para nosso gr\u00e1fico? ggplot(data = tab4, mapping = aes(x = factor(1), y = p, fill = categoria_idade)) + geom_col() + scale_fill_manual(values = c(\"#e63946\",\"#f1faee\", \"#a8dadc\", \"#457b9d\", \"#1d3557\")) + coord_polar(theta = 'y') + labs(title = \"As idades n\u00e3o possuem diferen\u00e7as\\nnot\u00e1veis quando em compara\u00e7\u00e3o\", x = \"EIXO X\", y = \"EIXO Y\", caption = \"TAXI DATA\") + theme_bw()","title":"Exerc\u00edcio"},{"location":"lidando_com_bancodados_parte1/","text":"Lidando com Banco de dados O tidyverse \u00e9 um pacote do R, mas pode tamb\u00e9m ser considerado como uma cole\u00e7\u00e3o de pacotes. Uma vez instalando o tidyverse , voc\u00ea tem acesso ao conte\u00fado de uma s\u00e9rie de outros pacotes (que tamb\u00e9m podem ser instalados individualmente). readr : importa\u00e7\u00e3o de dados; dplyr : manipula\u00e7\u00e3o de dados; tidyr : transforma\u00e7\u00e3o do data frame; tibble : auxilia na visualiza\u00e7\u00e3o de dados; stringr : manipula\u00e7\u00e3ode strings; ggplot2 : cria\u00e7\u00e3o de gr\u00e1ficos; purr : programa\u00e7\u00e3o funcional; forcats : manipula\u00e7\u00e3o fatores. . dplyr Dentre os pacotes mais importantes do tidyverse , o dplyr se destaca. Ele traz uma biblioteca pode rasa de fun\u00e7\u00f5es que nos permitem transformar dados. Essa \u00e9 a tarefa que voc\u00ea provavelmente passar\u00e1 mais tempo fazendo j\u00e1 que nem sempre os dados est\u00e3o limpos. Muitas vezes teremos que criar vari\u00e1veis ou extrair parte da informa\u00e7\u00e3o presente em uma antes de rodarmos um modelo. Quais s\u00e3o os verbos do dplyr ? Obviamente, o pacote \u00e9 extenso e possui uma quantidade razo\u00e1vel de fun\u00e7\u00f5es, mas queremos que voc\u00ea se atente, agora, a tr\u00eas fun\u00e7\u00f5es: select() , filter() , mutate() . dplyr e suas fun\u00e7\u00f5es Para tornar a manipula\u00e7\u00e3o de dados mais eficiente, foi criado um pacote chamado de dplyr que possui uma s\u00e9rie de ferramentas para filtrar, selecionar e sumarizar informa\u00e7\u00f5es, como veremos a seguir. Fun\u00e7\u00f5es As principais fun\u00e7\u00f5es do dplyr s\u00e3o: filter : filtra as linhas de um banco de dados de acordo com uma regra l\u00f3gica. select : seleciona as colunas de interesse. mutate : modifica ou cria colunas de acordo com valores fornecidos. count : conta os valores de uma vari\u00e1vel. Especialmente \u00fatil para vari\u00e1veis categ\u00f3ricas. rename : altera o nome das vari\u00e1veis (colunas). group_by e summarise : s\u00e3o fun\u00e7\u00f5es normalmente utilizadas em conjunto. Elas permitem realizar opera\u00e7\u00f5es de agrega\u00e7\u00f5es com o banco de dados e, assim, alterar a nossa unidade de an\u00e1lise. Por\u00e9m, n\u00e3o ficaremos apenas nestas fun\u00e7\u00f5es, veremos tamb\u00e9m algumas de suas varia\u00e7\u00f5es e conheceremos o famoso %>% (pipe). Como vimos, o dplyr \u00e9 um pacote essencial para manipula\u00e7\u00e3o de dados e uma das suas vantagens \u00e9 que a forma como aplicamos suas fun\u00e7\u00f5es segue o seguinte padr\u00e3o: funcao_dplyr(banco_de_dados, argumentos_especificos) Ou seja, o primeiro argumento de qualquer uma das fun\u00e7\u00f5es \u00e9 o banco de dados, seguido de argumentos espec\u00edficos de cada fun\u00e7\u00e3o, como por exemplo, qual vari\u00e1vel criar ou filtrar. rename() Se quisermos renomear o nome das vari\u00e1veis temos que utilizar o rename() que tem o seguinte padr\u00e3o: rename(bando_de_dados, nome_novo = nome_antigo) sat <- rename(sat, geo_location_code = dbn) sat select() Em muitas situa\u00e7\u00f5es n\u00f3s n\u00e3o trabalhamos com todas as vari\u00e1veis do banco de dados; para removermos aquelas colunas que n\u00e3o iremos utilizar, adotamos a fun\u00e7\u00e3o select() . Vamos selecionar apenas a idade e a press\u00e3o sangu\u00ednea. select(sat, nome_escola, media_leitura, media_redacao) Percebeu o padr\u00e3o dessa fun\u00e7\u00e3o? Basicamente \u00e9 o banco de dados e as vari\u00e1veis que queremos selecionar. Mas e se quisermos visualizar todas as vari\u00e1veis com exce\u00e7\u00e3o de algumas? select(sat, nome_escola, -media_mat) No exemplo acima estamos retirando as vari\u00e1veis target e restecg colocando um - na frente dessas vari\u00e1veis. Para darmos continuidade \u00e0s outras fun\u00e7\u00f5es vamos retirar algumas vari\u00e1veis amostra1 <- select(amostra1, -slope, -ca, -thal) filter() e um pouco de operadores l\u00f3gicos Quando estamos fazendo algumas an\u00e1lises, \u00e9 comum encontrarmos observa\u00e7\u00f5es que n\u00e3o nos interessam, como por exemplo, ao analisar as notas dos alunos que prestaram o sat, posso estar apenas interessada nas observa\u00e7\u00f5es de uma determinada escola. Neste caso, utilizamos o sinal ==, o que simboliza igual \u00e0. filter(sat, nome_escola == \u201cABRAHAM LINCOLN HIGH SCHOOL\u201d) Caso queriamos retirar determinadas observa\u00e7\u00f5es, usamos o != que simboliza a opera\u00e7\u00e3o diferente de: filter(sat, codigo_distrito_geo != 21) Quando usamos filtro, podemos realizar mais de uma opera\u00e7\u00e3o (mais de um filtro) de uma vez. Na linha abaixo, a v\u00edrgula significa E. Ou seja, filtramos os distritos cujo c\u00f3digo \u00e9 maior que 21, e o n\u00famero de alunos que realizaram a prova \u00e9 maior que 100. filter(sat, codigo_distrito_geo == 21, n_alunos > 100) Essa opera\u00e7\u00e3o pode ser realizada tamb\u00e9m com o operador &. filter(sat, codigo_distrito_geo == 21 & n_alunos > 100) Al\u00e9m do E, temos tamb\u00e9m o OU que \u00e9 simbolizado por uma barra. Aqui selecionados ou as linhas que cont\u00e9m o distrito 21 ou as linhas com n\u00famero de alunos que realizaram a prova \u00e9 maior que 100. filter(sat, codigo_distrito_geo == 21 | n_alunos > 100) De acordo com nossos prop\u00f3sitos, faz sentido usar o operador OU no lugar do operador E? Podemos tamb\u00e9m filtrar mais de um distrito de uma vez filter(sat, codigo_distrito_geo %in% c(21, 10)) amostra1 <- filter(sat, codigo_distrito_geo %in% c(21, 10), n_alunos > 100) mutate() Caso tenhamos interesse em alterar ou criar uma vari\u00e1vel, podemos utilizar o mutate() . A fun\u00e7\u00e3o tem o seguinte formato: mutate(bando_de_dados, coluna_nova|coluna_existente = valor) . Vamos aproveitar e criar uma nova a vari\u00e1vel que mostra o ano que o exame foi realizado amostra2 <- mutate(sat, ano = 2018) Com o mutate podemos tamb\u00e9m criar uma vari\u00e1vel a partir de uma j\u00e1 existente amostra3 <- mutate(amostra2, ano_caracter = ano) amostra3 <- mutate(amostra3, ano_caracter = as.character(ano_caracter)) Ou podemos essas opera\u00e7\u00f5es em um s\u00f3 comando: amostra4 <- mutate(sat, ano_caracter = as.character(2018)) Simples n\u00e3o? Al\u00e9m disso, podemos criar vari\u00e1veis categ\u00f3ricas, como por exemplo, uma vari\u00e1vel que identifica se a escola possui muitos ou poucos alunos prestando o SAT. amostra5 <- mutate(sat, categoria_escola = ifelse(n_alunos > 111, \"grande\", \"pequena\")) amostra5 Perceba que para criar essa vari\u00e1vel utilizamos uma fun\u00e7\u00e3o chamada ifelse() . Basicamente esta fun\u00e7\u00e3o \u00e9 um if em que o primeiro par\u00e2metro \u00e9 a condi\u00e7\u00e3o l\u00f3gica, o segundo \u00e9 a a\u00e7\u00e3o em caso de a condi\u00e7\u00e3o ser verdadeira e o terceiro \u00e9 a a\u00e7\u00e3o no caso de a condi\u00e7\u00e3o ser falsa. Assim, no caso acima ele pergunta: Se o valor da vari\u00e1vel n\u00famero de alunos por escola for maior que 111, classificamos como \u201cGrande\u201d, caso negativo, \u201cPequena\u201d. Agora que criamos a vari\u00e1vel \u201ccategoria_escola\u201d, quantas pessoas s\u00e3o idosas neste experimento? Para respondermos isso podemos utilizar a fun\u00e7\u00e3o count() count() Em uma tradu\u00e7\u00e3o literal, o count() ir\u00e1 contar as categorias de uma vari\u00e1vel. tabela_cat_escola <- count(amostra5, categoria_escola) tabela_cat_escola Portanto, podemos notar que existem mais adultos em nossa amostra.","title":"Lidando com Banco de dados"},{"location":"lidando_com_bancodados_parte1/#lidando-com-banco-de-dados","text":"O tidyverse \u00e9 um pacote do R, mas pode tamb\u00e9m ser considerado como uma cole\u00e7\u00e3o de pacotes. Uma vez instalando o tidyverse , voc\u00ea tem acesso ao conte\u00fado de uma s\u00e9rie de outros pacotes (que tamb\u00e9m podem ser instalados individualmente). readr : importa\u00e7\u00e3o de dados; dplyr : manipula\u00e7\u00e3o de dados; tidyr : transforma\u00e7\u00e3o do data frame; tibble : auxilia na visualiza\u00e7\u00e3o de dados; stringr : manipula\u00e7\u00e3ode strings; ggplot2 : cria\u00e7\u00e3o de gr\u00e1ficos; purr : programa\u00e7\u00e3o funcional; forcats : manipula\u00e7\u00e3o fatores.","title":"Lidando com Banco de dados"},{"location":"lidando_com_bancodados_parte1/#dplyr","text":"Dentre os pacotes mais importantes do tidyverse , o dplyr se destaca. Ele traz uma biblioteca pode rasa de fun\u00e7\u00f5es que nos permitem transformar dados. Essa \u00e9 a tarefa que voc\u00ea provavelmente passar\u00e1 mais tempo fazendo j\u00e1 que nem sempre os dados est\u00e3o limpos. Muitas vezes teremos que criar vari\u00e1veis ou extrair parte da informa\u00e7\u00e3o presente em uma antes de rodarmos um modelo. Quais s\u00e3o os verbos do dplyr ? Obviamente, o pacote \u00e9 extenso e possui uma quantidade razo\u00e1vel de fun\u00e7\u00f5es, mas queremos que voc\u00ea se atente, agora, a tr\u00eas fun\u00e7\u00f5es: select() , filter() , mutate() .","title":". dplyr"},{"location":"lidando_com_bancodados_parte1/#dplyr-e-suas-funcoes","text":"Para tornar a manipula\u00e7\u00e3o de dados mais eficiente, foi criado um pacote chamado de dplyr que possui uma s\u00e9rie de ferramentas para filtrar, selecionar e sumarizar informa\u00e7\u00f5es, como veremos a seguir.","title":"dplyr e suas fun\u00e7\u00f5es"},{"location":"lidando_com_bancodados_parte1/#funcoes","text":"As principais fun\u00e7\u00f5es do dplyr s\u00e3o: filter : filtra as linhas de um banco de dados de acordo com uma regra l\u00f3gica. select : seleciona as colunas de interesse. mutate : modifica ou cria colunas de acordo com valores fornecidos. count : conta os valores de uma vari\u00e1vel. Especialmente \u00fatil para vari\u00e1veis categ\u00f3ricas. rename : altera o nome das vari\u00e1veis (colunas). group_by e summarise : s\u00e3o fun\u00e7\u00f5es normalmente utilizadas em conjunto. Elas permitem realizar opera\u00e7\u00f5es de agrega\u00e7\u00f5es com o banco de dados e, assim, alterar a nossa unidade de an\u00e1lise. Por\u00e9m, n\u00e3o ficaremos apenas nestas fun\u00e7\u00f5es, veremos tamb\u00e9m algumas de suas varia\u00e7\u00f5es e conheceremos o famoso %>% (pipe). Como vimos, o dplyr \u00e9 um pacote essencial para manipula\u00e7\u00e3o de dados e uma das suas vantagens \u00e9 que a forma como aplicamos suas fun\u00e7\u00f5es segue o seguinte padr\u00e3o: funcao_dplyr(banco_de_dados, argumentos_especificos) Ou seja, o primeiro argumento de qualquer uma das fun\u00e7\u00f5es \u00e9 o banco de dados, seguido de argumentos espec\u00edficos de cada fun\u00e7\u00e3o, como por exemplo, qual vari\u00e1vel criar ou filtrar.","title":"Fun\u00e7\u00f5es"},{"location":"lidando_com_bancodados_parte1/#rename","text":"Se quisermos renomear o nome das vari\u00e1veis temos que utilizar o rename() que tem o seguinte padr\u00e3o: rename(bando_de_dados, nome_novo = nome_antigo) sat <- rename(sat, geo_location_code = dbn) sat","title":"rename()"},{"location":"lidando_com_bancodados_parte1/#select","text":"Em muitas situa\u00e7\u00f5es n\u00f3s n\u00e3o trabalhamos com todas as vari\u00e1veis do banco de dados; para removermos aquelas colunas que n\u00e3o iremos utilizar, adotamos a fun\u00e7\u00e3o select() . Vamos selecionar apenas a idade e a press\u00e3o sangu\u00ednea. select(sat, nome_escola, media_leitura, media_redacao) Percebeu o padr\u00e3o dessa fun\u00e7\u00e3o? Basicamente \u00e9 o banco de dados e as vari\u00e1veis que queremos selecionar. Mas e se quisermos visualizar todas as vari\u00e1veis com exce\u00e7\u00e3o de algumas? select(sat, nome_escola, -media_mat) No exemplo acima estamos retirando as vari\u00e1veis target e restecg colocando um - na frente dessas vari\u00e1veis. Para darmos continuidade \u00e0s outras fun\u00e7\u00f5es vamos retirar algumas vari\u00e1veis amostra1 <- select(amostra1, -slope, -ca, -thal)","title":"select()"},{"location":"lidando_com_bancodados_parte1/#filter-e-um-pouco-de-operadores-logicos","text":"Quando estamos fazendo algumas an\u00e1lises, \u00e9 comum encontrarmos observa\u00e7\u00f5es que n\u00e3o nos interessam, como por exemplo, ao analisar as notas dos alunos que prestaram o sat, posso estar apenas interessada nas observa\u00e7\u00f5es de uma determinada escola. Neste caso, utilizamos o sinal ==, o que simboliza igual \u00e0. filter(sat, nome_escola == \u201cABRAHAM LINCOLN HIGH SCHOOL\u201d) Caso queriamos retirar determinadas observa\u00e7\u00f5es, usamos o != que simboliza a opera\u00e7\u00e3o diferente de: filter(sat, codigo_distrito_geo != 21) Quando usamos filtro, podemos realizar mais de uma opera\u00e7\u00e3o (mais de um filtro) de uma vez. Na linha abaixo, a v\u00edrgula significa E. Ou seja, filtramos os distritos cujo c\u00f3digo \u00e9 maior que 21, e o n\u00famero de alunos que realizaram a prova \u00e9 maior que 100. filter(sat, codigo_distrito_geo == 21, n_alunos > 100) Essa opera\u00e7\u00e3o pode ser realizada tamb\u00e9m com o operador &. filter(sat, codigo_distrito_geo == 21 & n_alunos > 100) Al\u00e9m do E, temos tamb\u00e9m o OU que \u00e9 simbolizado por uma barra. Aqui selecionados ou as linhas que cont\u00e9m o distrito 21 ou as linhas com n\u00famero de alunos que realizaram a prova \u00e9 maior que 100. filter(sat, codigo_distrito_geo == 21 | n_alunos > 100) De acordo com nossos prop\u00f3sitos, faz sentido usar o operador OU no lugar do operador E? Podemos tamb\u00e9m filtrar mais de um distrito de uma vez filter(sat, codigo_distrito_geo %in% c(21, 10)) amostra1 <- filter(sat, codigo_distrito_geo %in% c(21, 10), n_alunos > 100)","title":"filter() e um pouco de operadores l\u00f3gicos"},{"location":"lidando_com_bancodados_parte1/#mutate","text":"Caso tenhamos interesse em alterar ou criar uma vari\u00e1vel, podemos utilizar o mutate() . A fun\u00e7\u00e3o tem o seguinte formato: mutate(bando_de_dados, coluna_nova|coluna_existente = valor) . Vamos aproveitar e criar uma nova a vari\u00e1vel que mostra o ano que o exame foi realizado amostra2 <- mutate(sat, ano = 2018) Com o mutate podemos tamb\u00e9m criar uma vari\u00e1vel a partir de uma j\u00e1 existente amostra3 <- mutate(amostra2, ano_caracter = ano) amostra3 <- mutate(amostra3, ano_caracter = as.character(ano_caracter)) Ou podemos essas opera\u00e7\u00f5es em um s\u00f3 comando: amostra4 <- mutate(sat, ano_caracter = as.character(2018)) Simples n\u00e3o? Al\u00e9m disso, podemos criar vari\u00e1veis categ\u00f3ricas, como por exemplo, uma vari\u00e1vel que identifica se a escola possui muitos ou poucos alunos prestando o SAT. amostra5 <- mutate(sat, categoria_escola = ifelse(n_alunos > 111, \"grande\", \"pequena\")) amostra5 Perceba que para criar essa vari\u00e1vel utilizamos uma fun\u00e7\u00e3o chamada ifelse() . Basicamente esta fun\u00e7\u00e3o \u00e9 um if em que o primeiro par\u00e2metro \u00e9 a condi\u00e7\u00e3o l\u00f3gica, o segundo \u00e9 a a\u00e7\u00e3o em caso de a condi\u00e7\u00e3o ser verdadeira e o terceiro \u00e9 a a\u00e7\u00e3o no caso de a condi\u00e7\u00e3o ser falsa. Assim, no caso acima ele pergunta: Se o valor da vari\u00e1vel n\u00famero de alunos por escola for maior que 111, classificamos como \u201cGrande\u201d, caso negativo, \u201cPequena\u201d. Agora que criamos a vari\u00e1vel \u201ccategoria_escola\u201d, quantas pessoas s\u00e3o idosas neste experimento? Para respondermos isso podemos utilizar a fun\u00e7\u00e3o count()","title":"mutate()"},{"location":"lidando_com_bancodados_parte1/#count","text":"Em uma tradu\u00e7\u00e3o literal, o count() ir\u00e1 contar as categorias de uma vari\u00e1vel. tabela_cat_escola <- count(amostra5, categoria_escola) tabela_cat_escola Portanto, podemos notar que existem mais adultos em nossa amostra.","title":"count()"}]}